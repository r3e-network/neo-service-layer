name: üöÄ Neo Service Layer CI/CD Pipeline

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip test execution'
        required: false
        default: false
        type: boolean
      skip_docker:
        description: 'Skip Docker build'
        required: false
        default: false
        type: boolean

env:
  DOTNET_VERSION: '9.0.x'
  NODE_VERSION: '20'
  RUST_VERSION: 'stable'
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  COVERAGE_THRESHOLD: 75
  BRANCH_COVERAGE_THRESHOLD: 70

jobs:
  # üèóÔ∏è Build and Test Matrix Job
  build-and-test:
    name: üèóÔ∏è Build & Test (${{ matrix.configuration }})
    runs-on: ubuntu-latest
    timeout-minutes: 45
    if: ${{ !github.event.inputs.skip_tests }}
    
    strategy:
      fail-fast: false
      matrix:
        configuration: [Debug, Release]
        include:
          - configuration: Debug
            collect_coverage: false
            run_integration: false
          - configuration: Release
            collect_coverage: true
            run_integration: true
    
    outputs:
      test-results-available: ${{ steps.test-check.outputs.available }}
      coverage-results-available: ${{ steps.coverage-check.outputs.available }}
    
    steps:
    - name: üì• Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: üîß Setup development environment
      uses: ./.github/actions/setup-dev-env
      if: ${{ false }} # Disable custom action for now
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
        node-version: ${{ env.NODE_VERSION }}
        rust-version: ${{ env.RUST_VERSION }}

    # Fallback setup when custom action is not available
    - name: üîß Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: üîß Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: '**/package-lock.json'

    - name: üîß Setup Rust toolchain
      uses: dtolnay/rust-toolchain@stable
      with:
        toolchain: ${{ env.RUST_VERSION }}
        components: rustfmt, clippy

    - name: üöÄ Cache dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.nuget/packages
          ~/.cargo/bin/
          ~/.cargo/registry/index/
          ~/.cargo/registry/cache/
          ~/.cargo/git/db/
          src/Tee/NeoServiceLayer.Tee.Enclave/target/
          node_modules
        key: ${{ runner.os }}-deps-${{ hashFiles('**/*.csproj', '**/Cargo.lock', '**/package-lock.json', 'global.json') }}
        restore-keys: |
          ${{ runner.os }}-deps-
          ${{ runner.os }}-nuget-
          ${{ runner.os }}-cargo-

    - name: üîí Install SGX SDK (Simulation Mode)
      run: |
        echo "::group::Installing Intel SGX SDK for CI simulation"
        wget -qO - https://download.01.org/intel-sgx/sgx_repo/ubuntu/intel-sgx-deb.key | sudo apt-key add -
        echo "deb [arch=amd64] https://download.01.org/intel-sgx/sgx_repo/ubuntu $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/intel-sgx.list
        sudo apt-get update
        sudo apt-get install -y libsgx-urts libsgx-enclave-common-dev libsgx-dcap-ql-dev
        echo "SGX_MODE=SIM" >> $GITHUB_ENV
        echo "::endgroup::"

    - name: üì¶ Restore dependencies
      run: |
        echo "::group::Restoring .NET dependencies"
        dotnet restore --verbosity minimal
        echo "::endgroup::"
        
        echo "::group::Installing Solidity dependencies"
        if [ -d "contracts" ]; then
          cd contracts && npm ci --silent
        else
          echo "No contracts directory found, skipping Solidity dependencies"
        fi
        echo "::endgroup::"

    - name: üèóÔ∏è Build solution
      run: |
        echo "::group::Building solution (${{ matrix.configuration }})"
        dotnet build \
          --configuration ${{ matrix.configuration }} \
          --no-restore \
          --verbosity minimal \
          --property WarningLevel=0 \
          --property TreatWarningsAsErrors=true
        echo "::endgroup::"

    - name: üß™ Run unit tests  
      if: ${{ !github.event.inputs.skip_tests }}
      run: |
        echo "::group::Running unit tests (${{ matrix.configuration }})"
        dotnet test \
          --configuration ${{ matrix.configuration }} \
          --no-build \
          --verbosity minimal \
          --logger trx \
          --results-directory TestResults/Unit/ \
          ${{ matrix.collect_coverage && '--collect:"XPlat Code Coverage" --settings tests/codecoverage.runsettings' || '' }} \
          --filter "Category!=Integration&Category!=Performance"
        echo "::endgroup::"

    - name: üîó Run integration tests
      if: ${{ matrix.run_integration && !github.event.inputs.skip_tests }}
      env:
        SGX_MODE: SIM
        TEST_ENVIRONMENT: CI
      run: |
        echo "::group::Running integration tests"
        dotnet test tests/Integration/ \
          --configuration ${{ matrix.configuration }} \
          --no-build \
          --verbosity minimal \
          --logger trx \
          --results-directory TestResults/Integration/ \
          ${{ matrix.collect_coverage && '--collect:"XPlat Code Coverage"' || '' }}
        echo "::endgroup::"

    - name: üîó Run Solidity tests
      if: ${{ !github.event.inputs.skip_tests }}
      working-directory: contracts
      run: |
        if [ -f "package.json" ]; then
          echo "::group::Running Solidity tests"
          npm test
          echo "::endgroup::"
        else
          echo "No Solidity tests found, skipping"
        fi

    - name: üìä Generate coverage report
      if: ${{ matrix.collect_coverage && !github.event.inputs.skip_tests }}
      uses: danielpalme/ReportGenerator-GitHub-Action@5.2.0
      with:
        reports: 'TestResults/**/coverage.cobertura.xml'
        targetdir: 'TestResults/CoverageReport'
        reporttypes: 'HtmlInline_AzurePipelines;Cobertura;JsonSummary;Badges'
        verbosity: 'Warning'

    - name: üìà Check coverage thresholds
      id: coverage-check
      if: ${{ matrix.collect_coverage && !github.event.inputs.skip_tests }}
      run: |
        if [ -f "TestResults/CoverageReport/Summary.json" ]; then
          echo "::group::Coverage Analysis"
          COVERAGE=$(cat TestResults/CoverageReport/Summary.json | jq -r '.coverage.linecoverage // 0')
          BRANCH_COVERAGE=$(cat TestResults/CoverageReport/Summary.json | jq -r '.coverage.branchcoverage // 0')
          
          echo "Line coverage: ${COVERAGE}%"
          echo "Branch coverage: ${BRANCH_COVERAGE}%"
          echo "line-coverage=${COVERAGE}" >> $GITHUB_OUTPUT
          echo "branch-coverage=${BRANCH_COVERAGE}" >> $GITHUB_OUTPUT
          echo "available=true" >> $GITHUB_OUTPUT
          
          # Check thresholds
          if (( $(echo "${COVERAGE} >= ${COVERAGE_THRESHOLD}" | bc -l) )) && (( $(echo "${BRANCH_COVERAGE} >= ${BRANCH_COVERAGE_THRESHOLD}" | bc -l) )); then
            echo "coverage-passed=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Code coverage meets threshold: ${COVERAGE}% line, ${BRANCH_COVERAGE}% branch"
          else
            echo "coverage-passed=false" >> $GITHUB_OUTPUT
            echo "‚ùå Coverage below threshold: ${COVERAGE}% line (>=${COVERAGE_THRESHOLD}%), ${BRANCH_COVERAGE}% branch (>=${BRANCH_COVERAGE_THRESHOLD}%)"
          fi
          echo "::endgroup::"
        else
          echo "‚ö†Ô∏è No coverage report found"
          echo "available=false" >> $GITHUB_OUTPUT
          echo "coverage-passed=false" >> $GITHUB_OUTPUT
        fi

    - name: üì§ Upload test results
      uses: actions/upload-artifact@v4
      if: ${{ always() && !github.event.inputs.skip_tests }}
      with:
        name: test-results-${{ matrix.configuration }}-${{ github.run_number }}
        path: TestResults/
        retention-days: 30
        compression-level: 6

    - name: üìà Set test check outputs
      id: test-check
      if: ${{ !github.event.inputs.skip_tests }}
      run: |
        echo "available=true" >> $GITHUB_OUTPUT

    - name: üéØ Upload coverage to Codecov
      if: ${{ matrix.collect_coverage && !github.event.inputs.skip_tests }}
      uses: codecov/codecov-action@v4
      with:
        files: TestResults/CoverageReport/Cobertura.xml
        flags: unittests,integration
        name: neo-service-layer-${{ matrix.configuration }}
        fail_ci_if_error: false
        verbose: false
        token: ${{ secrets.CODECOV_TOKEN }}

    - name: üí¨ Comment PR with coverage
      if: ${{ github.event_name == 'pull_request' && matrix.collect_coverage && !github.event.inputs.skip_tests }}
      uses: 5monkeys/cobertura-action@master
      with:
        path: TestResults/CoverageReport/Cobertura.xml
        minimum_coverage: ${{ env.COVERAGE_THRESHOLD }}
        fail_below_minimum: false
        show_missing: true
        show_line: true
        show_branch: true
        show_class_names: true

  # üîí Security Analysis Job
  security-analysis:
    name: üîí Security Analysis
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      actions: read
      contents: read
      security-events: write
    
    strategy:
      matrix:
        analysis: [codeql, dependency-check]
        include:
          - analysis: codeql
            name: "CodeQL Analysis"
            languages: "csharp,javascript"
          - analysis: dependency-check
            name: "Dependency Security Check"
    
    steps:
    - name: üì• Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: üîß Setup .NET
      if: ${{ matrix.analysis == 'codeql' }}
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: üîç Initialize CodeQL
      if: ${{ matrix.analysis == 'codeql' }}
      uses: github/codeql-action/init@v3
      with:
        languages: ${{ matrix.languages }}
        config-file: ./.github/codeql/codeql-config.yml

    - name: üèóÔ∏è Build for CodeQL
      if: ${{ matrix.analysis == 'codeql' }}
      run: |
        echo "::group::Building for CodeQL analysis"
        dotnet restore --verbosity quiet
        dotnet build --configuration Release --no-restore --verbosity quiet
        echo "::endgroup::"

    - name: üîç Perform CodeQL Analysis
      if: ${{ matrix.analysis == 'codeql' }}
      uses: github/codeql-action/analyze@v3
      with:
        category: "/language:${{ matrix.languages }}"
        upload: true

    - name: üì¶ Check vulnerable packages
      if: ${{ matrix.analysis == 'dependency-check' }}
      run: |
        echo "::group::Checking for vulnerable NuGet packages"
        if dotnet list package --vulnerable --include-transitive 2>&1 | grep -q "has the following vulnerable packages"; then
          echo "‚ùå Vulnerable packages detected:"
          dotnet list package --vulnerable --include-transitive
          exit 1
        else
          echo "‚úÖ No vulnerable packages detected"
        fi
        echo "::endgroup::"

    - name: üîç Run Snyk security scan
      if: ${{ matrix.analysis == 'dependency-check' && secrets.SNYK_TOKEN }}
      uses: snyk/actions/dotnet@master
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      with:
        args: --severity-threshold=high --all-projects --detection-depth=3
        command: test

    - name: üì§ Upload Snyk results
      if: ${{ matrix.analysis == 'dependency-check' && secrets.SNYK_TOKEN && always() }}
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: snyk.sarif

  # üéØ Quality Gate Job
  quality-gate:
    name: üéØ Quality Gate & Analysis
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [build-and-test]
    if: ${{ needs.build-and-test.outputs.coverage-results-available == 'true' }}
    
    steps:
    - name: üì• Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: üîß Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: üìä Install SonarCloud scanner
      if: ${{ secrets.SONAR_TOKEN }}
      run: |
        echo "::group::Installing SonarCloud scanner"
        dotnet tool install --global dotnet-sonarscanner --version 6.0.0
        echo "::endgroup::"

    - name: üîç Begin SonarCloud analysis
      if: ${{ secrets.SONAR_TOKEN }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      run: |
        echo "::group::Starting SonarCloud analysis"
        dotnet sonarscanner begin \
          /k:"neo-service-layer" \
          /o:"neo-project" \
          /d:sonar.token="${{ secrets.SONAR_TOKEN }}" \
          /d:sonar.host.url="https://sonarcloud.io" \
          /d:sonar.cs.opencover.reportsPaths="TestResults/**/coverage.opencover.xml" \
          /d:sonar.coverage.exclusions="**/bin/**,**/obj/**,**/*Tests.cs,**/Program.cs,**/Migrations/**" \
          /d:sonar.exclusions="**/bin/**,**/obj/**,**/wwwroot/lib/**" \
          /d:sonar.cpd.exclusions="**/Migrations/**" \
          /v:"${{ github.sha }}"
        echo "::endgroup::"

    - name: üèóÔ∏è Build for SonarCloud
      if: ${{ secrets.SONAR_TOKEN }}
      run: |
        echo "::group::Building for SonarCloud"
        dotnet build --configuration Release --verbosity quiet
        echo "::endgroup::"

    - name: üîç Complete SonarCloud analysis
      if: ${{ secrets.SONAR_TOKEN }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      run: |
        echo "::group::Completing SonarCloud analysis"
        dotnet sonarscanner end /d:sonar.token="${{ secrets.SONAR_TOKEN }}"
        echo "::endgroup::"

  # üöÄ Performance Testing Job
  performance-tests:
    name: üöÄ Performance Tests
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [build-and-test]
    if: ${{ github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') && !github.event.inputs.skip_tests }}
    
    steps:
    - name: üì• Checkout repository
      uses: actions/checkout@v4

    - name: üîß Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: üöÄ Cache dependencies
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-perf-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: üì¶ Restore dependencies
      run: dotnet restore --verbosity minimal

    - name: üèÉ Run performance tests
      env:
        SGX_MODE: SIM
        PERFORMANCE_TEST_DURATION: "30s"
      run: |
        echo "::group::Running performance tests"
        dotnet test tests/Performance/ \
          --configuration Release \
          --no-restore \
          --logger "console;verbosity=detailed" \
          --logger "trx;LogFileName=performance-results.trx" \
          --results-directory TestResults/Performance/ \
          --filter "Category=Performance" \
          -- RunConfiguration.TestSessionTimeout=1800000
        echo "::endgroup::"

    - name: üì§ Upload performance results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: performance-test-results-${{ github.run_number }}
        path: TestResults/Performance/
        retention-days: 7

    - name: üìä Performance regression check
      run: |
        echo "::group::Performance regression analysis"
        # Add performance regression logic here
        echo "Performance tests completed successfully"
        echo "::endgroup::"

  # üê≥ Docker Build Matrix Job
  docker-build:
    name: üê≥ Docker Build (${{ matrix.variant }})
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [build-and-test, security-analysis]
    if: ${{ !github.event.inputs.skip_docker }}
    permissions:
      contents: read
      packages: write
      id-token: write
    
    strategy:
      fail-fast: false
      matrix:
        variant: [production, development]
        include:
          - variant: production
            dockerfile: Dockerfile
            platforms: linux/amd64,linux/arm64
            suffix: ""
            build_args: |
              SGX_MODE=SIM
              BUILDKIT_INLINE_CACHE=1
              BUILD_CONFIGURATION=Release
          - variant: development
            dockerfile: Dockerfile.ubuntu24
            platforms: linux/amd64
            suffix: -dev
            build_args: |
              SGX_MODE=SIM
              BUILD_CONFIGURATION=Debug
    
    steps:
    - name: üì• Checkout repository
      uses: actions/checkout@v4

    - name: üîß Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: |
          network=host

    - name: üìù Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: üè∑Ô∏è Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        flavor: |
          latest=auto
          suffix=${{ matrix.suffix }},onlatest=true
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value=stable,enable=${{ github.ref == 'refs/heads/master' }}
        labels: |
          org.opencontainers.image.title=Neo Service Layer
          org.opencontainers.image.description=Enterprise-grade blockchain service layer for Neo
          org.opencontainers.image.vendor=Neo Project
          org.opencontainers.image.version={{version}}
          org.opencontainers.image.created={{date 'iso8601'}}
          org.opencontainers.image.revision={{sha}}
          org.opencontainers.image.url=https://github.com/${{ github.repository }}

    - name: üê≥ Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ${{ matrix.dockerfile }}
        platforms: ${{ matrix.platforms }}
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha,scope=${{ matrix.variant }}
        cache-to: type=gha,mode=max,scope=${{ matrix.variant }}
        build-args: ${{ matrix.build_args }}
        provenance: true
        sbom: true

    - name: üîç Run container security scan
      uses: anchore/scan-action@v3
      if: ${{ matrix.variant == 'production' }}
      with:
        image: ${{ steps.meta.outputs.tags }}
        fail-build: false
        severity-cutoff: high
        acs-report-enable: true

    - name: üì§ Upload container scan results
      uses: github/codeql-action/upload-sarif@v3
      if: ${{ matrix.variant == 'production' && always() }}
      with:
        sarif_file: results.sarif

  # üöÄ Deployment Matrix Job
  deploy:
    name: üöÄ Deploy to ${{ matrix.environment }}
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [docker-build, quality-gate]
    if: ${{ success() && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') }}
    environment: ${{ matrix.environment }}
    
    strategy:
      matrix:
        include:
          - environment: development
            condition: ${{ github.ref == 'refs/heads/develop' }}
            api_url: ${{ secrets.DEV_API_URL }}
            deployment_script: deploy-dev.sh
          - environment: staging
            condition: ${{ github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' }}
            api_url: ${{ secrets.STAGING_API_URL }}
            deployment_script: deploy-staging.sh
    
    steps:
    - name: üì• Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 1

    - name: üîß Setup deployment tools
      run: |
        echo "::group::Installing deployment tools"
        # Install kubectl if needed
        if command -v kubectl &> /dev/null; then
          echo "kubectl already installed"
        else
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
        fi
        
        # Install Helm if needed
        if command -v helm &> /dev/null; then
          echo "Helm already installed"
        else
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
        fi
        echo "::endgroup::"

    - name: üîë Configure deployment credentials
      env:
        KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}
        DEPLOY_KEY: ${{ secrets.DEPLOY_KEY }}
      run: |
        echo "::group::Configuring deployment credentials"
        # Configure kubectl
        if [ -n "$KUBE_CONFIG" ]; then
          echo "$KUBE_CONFIG" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config
        fi
        
        # Configure deployment key
        if [ -n "$DEPLOY_KEY" ]; then
          echo "$DEPLOY_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
        fi
        echo "::endgroup::"

    - name: üöÄ Deploy to ${{ matrix.environment }}
      env:
        ENVIRONMENT: ${{ matrix.environment }}
        IMAGE_TAG: ${{ github.sha }}
        API_URL: ${{ matrix.api_url }}
      run: |
        echo "::group::Deploying to ${{ matrix.environment }}"
        
        # Example deployment using Helm
        if [ -f "deploy/helm/neo-service-layer/Chart.yaml" ]; then
          helm upgrade --install neo-service-layer \
            ./deploy/helm/neo-service-layer \
            --namespace neo-service-layer-${{ matrix.environment }} \
            --create-namespace \
            --set image.tag=${IMAGE_TAG} \
            --set environment=${{ matrix.environment }} \
            --wait --timeout=10m
        else
          echo "Helm chart not found, using alternative deployment method"
          # Add alternative deployment logic here
          echo "Deployment would happen here for ${{ matrix.environment }}"
        fi
        echo "::endgroup::"

    - name: ‚è≥ Wait for deployment to be ready
      timeout-minutes: 5
      run: |
        echo "::group::Waiting for deployment to be ready"
        for i in {1..30}; do
          if curl -f -m 10 "${{ matrix.api_url }}/health" > /dev/null 2>&1; then
            echo "‚úÖ Service is healthy"
            break
          fi
          echo "‚è≥ Waiting for service to be ready... (attempt $i/30)"
          sleep 10
        done
        echo "::endgroup::"

    - name: üß™ Run smoke tests
      env:
        API_URL: ${{ matrix.api_url }}
        TEST_TIMEOUT: "30s"
      run: |
        echo "::group::Running smoke tests"
        
        # Health check
        echo "Testing health endpoint..."
        curl -f -m 10 "$API_URL/health" || exit 1
        
        # API version check
        echo "Testing API version..."
        curl -f -m 10 "$API_URL/api/version" || exit 1
        
        # Additional smoke tests
        if [ -f "tests/smoke/run-smoke-tests.sh" ]; then
          chmod +x tests/smoke/run-smoke-tests.sh
          ./tests/smoke/run-smoke-tests.sh "$API_URL"
        else
          echo "No additional smoke tests found"
        fi
        
        echo "‚úÖ All smoke tests passed"
        echo "::endgroup::"

    - name: üìä Run E2E tests
      if: ${{ matrix.environment == 'staging' }}
      env:
        API_URL: ${{ matrix.api_url }}
        E2E_TEST_TIMEOUT: "300s"
      run: |
        echo "::group::Running end-to-end tests"
        
        if [ -f "tests/e2e/run-e2e-tests.sh" ]; then
          chmod +x tests/e2e/run-e2e-tests.sh
          ./tests/e2e/run-e2e-tests.sh "$API_URL"
        else
          echo "No E2E tests found, skipping"
        fi
        
        echo "‚úÖ E2E tests completed"
        echo "::endgroup::"

    - name: üì¢ Notify deployment status
      uses: 8398a7/action-slack@v3
      if: ${{ always() && secrets.SLACK_WEBHOOK }}
      with:
        status: ${{ job.status }}
        channel: '#deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        fields: repo,message,commit,author,action,eventName,ref,workflow,job,took
        custom_payload: |
          {
            attachments: [{
              color: '${{ job.status }}' === 'success' ? 'good' : '${{ job.status }}' === 'failure' ? 'danger' : 'warning',
              blocks: [{
                type: 'section',
                text: {
                  type: 'mrkdwn',
                  text: `üöÄ Deployment to *${{ matrix.environment }}* ${job.status === 'success' ? '‚úÖ succeeded' : '‚ùå failed'}\n*Repository:* ${{ github.repository }}\n*Branch:* ${{ github.ref_name }}\n*Commit:* ${{ github.sha }}\n*Workflow:* ${{ github.workflow }}`
                }
              }]
            }]
          }

  # üéâ Summary & Notification Job
  workflow-summary:
    name: üéâ Workflow Summary
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [build-and-test, security-analysis, quality-gate, performance-tests, docker-build, deploy]
    if: always()
    
    steps:
    - name: üìä Generate workflow summary
      run: |
        echo "# üöÄ Neo Service Layer CI/CD Pipeline Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## üìã Job Status Overview" >> $GITHUB_STEP_SUMMARY
        echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| Build & Test | ${{ needs.build-and-test.result == 'success' && '‚úÖ Success' || needs.build-and-test.result == 'failure' && '‚ùå Failed' || needs.build-and-test.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ö†Ô∏è Cancelled' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Security Analysis | ${{ needs.security-analysis.result == 'success' && '‚úÖ Success' || needs.security-analysis.result == 'failure' && '‚ùå Failed' || needs.security-analysis.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ö†Ô∏è Cancelled' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Quality Gate | ${{ needs.quality-gate.result == 'success' && '‚úÖ Success' || needs.quality-gate.result == 'failure' && '‚ùå Failed' || needs.quality-gate.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ö†Ô∏è Cancelled' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Performance Tests | ${{ needs.performance-tests.result == 'success' && '‚úÖ Success' || needs.performance-tests.result == 'failure' && '‚ùå Failed' || needs.performance-tests.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ö†Ô∏è Cancelled' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Docker Build | ${{ needs.docker-build.result == 'success' && '‚úÖ Success' || needs.docker-build.result == 'failure' && '‚ùå Failed' || needs.docker-build.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ö†Ô∏è Cancelled' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Deployment | ${{ needs.deploy.result == 'success' && '‚úÖ Success' || needs.deploy.result == 'failure' && '‚ùå Failed' || needs.deploy.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ö†Ô∏è Cancelled' }} |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## üîó Quick Links" >> $GITHUB_STEP_SUMMARY
        echo "- üìä [Code Coverage Report](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts)" >> $GITHUB_STEP_SUMMARY
        echo "- üîí [Security Analysis](https://github.com/${{ github.repository }}/security)" >> $GITHUB_STEP_SUMMARY
        echo "- üê≥ [Container Images](https://github.com/${{ github.repository }}/pkgs/container/neo-service-layer)" >> $GITHUB_STEP_SUMMARY
        echo "- üìà [SonarCloud Analysis](https://sonarcloud.io/project/overview?id=neo-service-layer)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Workflow completed at:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

    - name: üßπ Cleanup old artifacts
      uses: actions/github-script@v7
      with:
        script: |
          console.log('üßπ Cleaning up old artifacts...');
          
          try {
            const allArtifacts = await github.rest.actions.listArtifactsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });
            
            // Keep only the latest 20 artifacts per workflow run
            const artifactsByWorkflow = {};
            
            for (const artifact of allArtifacts.data.artifacts) {
              const workflowKey = artifact.workflow_run?.id || 'unknown';
              if (!artifactsByWorkflow[workflowKey]) {
                artifactsByWorkflow[workflowKey] = [];
              }
              artifactsByWorkflow[workflowKey].push(artifact);
            }
            
            let deletedCount = 0;
            
            for (const [workflowId, artifacts] of Object.entries(artifactsByWorkflow)) {
              // Sort by creation date, newest first
              artifacts.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
              
              // Delete artifacts beyond the first 20 for each workflow
              const toDelete = artifacts.slice(20);
              
              for (const artifact of toDelete) {
                try {
                  await github.rest.actions.deleteArtifact({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    artifact_id: artifact.id,
                  });
                  console.log(`‚úÖ Deleted artifact: ${artifact.name} (${artifact.id})`);
                  deletedCount++;
                } catch (error) {
                  console.log(`‚ö†Ô∏è Could not delete artifact ${artifact.name}: ${error.message}`);
                }
              }
            }
            
            console.log(`üéâ Cleanup completed. Deleted ${deletedCount} old artifacts.`);
          } catch (error) {
            console.log(`‚ö†Ô∏è Cleanup failed: ${error.message}`);
          }