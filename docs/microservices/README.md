# Neo Service Layer - Microservices Architecture

This document describes the microservices architecture implementation of the Neo Service Layer, providing scalable, containerized services with service discovery, monitoring, and deployment automation.

## Architecture Overview

The Neo Service Layer has been transformed into a microservices architecture with the following components:

### Core Components

1. **API Gateway** - YARP-based reverse proxy for unified API access
2. **Service Discovery** - Consul-based service registry and discovery
3. **Configuration Management** - Centralized configuration with Consul
4. **Monitoring Stack** - Prometheus + Grafana for metrics and monitoring
5. **Message Queue** - RabbitMQ for async communication
6. **Databases** - PostgreSQL for persistent storage, Redis for caching

### Microservices

The system includes 22 individual microservices, each running in its own container:

#### Core Services
- **Notification Service** (Port 5010) - Email, SMS, and push notifications
- **Configuration Service** (Port 5011) - System configuration management
- **Backup Service** (Port 5012) - Data backup and recovery
- **Storage Service** (Port 5013) - File and data storage

#### Blockchain Services
- **Smart Contracts Service** (Port 5014) - Contract deployment and execution
- **Cross Chain Service** (Port 5015) - Cross-chain interoperability
- **Oracle Service** (Port 5016) - External data feeds
- **Proof of Reserve Service** (Port 5017) - Asset verification

#### Security Services
- **Key Management Service** (Port 5018) - Cryptographic key management
- **Abstract Account Service** (Port 5019) - Account abstraction
- **Zero Knowledge Service** (Port 5020) - ZK proof generation
- **Compliance Service** (Port 5021) - Regulatory compliance
- **Secrets Management Service** (Port 5022) - Secret storage
- **Social Recovery Service** (Port 5023) - Account recovery
- **Network Security Service** (Port 5024) - Network protection

#### Infrastructure Services
- **Monitoring Service** (Port 5025) - System monitoring
- **Health Service** (Port 5026) - Health checks
- **Automation Service** (Port 5027) - Task automation
- **Event Subscription Service** (Port 5028) - Event handling

#### Computational Services
- **Compute Service** (Port 5029) - General computation
- **Randomness Service** (Port 5030) - Random number generation
- **Voting Service** (Port 5031) - Governance voting
- **Enclave Storage Service** (Port 5032) - SGX enclave storage

## Quick Start

### Prerequisites

- Docker and Docker Compose
- Git
- 8GB+ RAM recommended
- 20GB+ disk space

### 1. Clone and Setup

```bash
git clone <repository-url>
cd neo-service-layer
git checkout microservices
```

### 2. Deploy Infrastructure

```bash
# Build base images and deploy all services
./scripts/deploy-microservices.sh

# Or with cleanup
CLEANUP=true ./scripts/deploy-microservices.sh
```

### 3. Access Services

- **API Gateway**: http://localhost:5000
- **Consul UI**: http://localhost:8500
- **Grafana**: http://localhost:3000 (admin/admin)
- **Prometheus**: http://localhost:9090
- **RabbitMQ**: http://localhost:15672 (guest/guest)

## Configuration

### Environment Variables

The system uses environment variables for configuration. Key variables include:

```bash
# Core Configuration
ASPNETCORE_ENVIRONMENT=Development
JWT_SECRET_KEY=<auto-generated>
SGX_MODE=SIM

# Database Configuration
POSTGRES_PASSWORD=neopass123
REDIS_PASSWORD=
RABBITMQ_PASSWORD=guest

# Service Discovery
CONSUL_ADDRESS=http://consul:8500
CONSUL_DATACENTER=dc1

# Service Ports
NOTIFICATION_PORT=5010
CONFIGURATION_PORT=5011
# ... (see .env file for full list)
```

### Service-Specific Configuration

Each service can be configured through:

1. **Environment Variables** - Runtime configuration
2. **Consul KV Store** - Dynamic configuration
3. **Configuration Files** - Service-specific settings

## Service Discovery

Services automatically register with Consul on startup and discover other services through the service registry.

### Service Registration

```csharp
// Each service automatically registers itself
var serviceInfo = new ServiceInfo
{
    ServiceName = "NotificationService",
    ServiceType = "Notification",
    HostName = Environment.GetEnvironmentVariable("HOSTNAME"),
    Port = 80,
    HealthCheckEndpoint = "/health"
};

await serviceRegistry.RegisterServiceAsync(serviceInfo);
```

### Service Discovery

```csharp
// Services can discover other services
var services = await serviceRegistry.DiscoverServicesAsync("SmartContracts");
```

## API Gateway

The API Gateway provides a unified entry point for all services:

### Route Configuration

```yaml
# Example route configuration
Routes:
  - ClusterId: "notification-service"
    Match:
      Path: "/api/notifications/{**catch-all}"
    Transforms:
      - PathPattern: "/api/notifications/{**catch-all}"
    
  - ClusterId: "smart-contracts-service"
    Match:
      Path: "/api/smart-contracts/{**catch-all}"
    Transforms:
      - PathPattern: "/api/smart-contracts/{**catch-all}"
```

### Load Balancing

The gateway supports multiple load balancing strategies:
- Round Robin (default)
- Least Connections
- Random
- Consistent Hashing

## Monitoring and Observability

### Metrics Collection

Each service exposes Prometheus metrics at `/metrics`:

```
# Service-specific metrics
service_requests_total{service="notification",status="success"} 1250
service_requests_total{service="notification",status="failed"} 15
service_response_time_seconds{service="notification",quantile="0.5"} 0.025
```

### Health Checks

All services implement health checks at `/health`:

```json
{
  "status": "Healthy",
  "totalDuration": "00:00:00.0123456",
  "entries": {
    "notification_service": {
      "status": "Healthy",
      "description": "Service is healthy"
    }
  }
}
```

### Distributed Tracing

Services support distributed tracing through OpenTelemetry:

```csharp
// Tracing configuration
services.AddOpenTelemetry()
    .WithTracing(builder =>
    {
        builder.AddAspNetCoreInstrumentation()
               .AddHttpClientInstrumentation()
               .AddJaegerExporter();
    });
```

## Security

### Authentication and Authorization

Services use JWT tokens for authentication:

```csharp
services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = jwtSettings.Issuer,
            ValidAudience = jwtSettings.Audience,
            IssuerSigningKey = new SymmetricSecurityKey(jwtSettings.SecretKey)
        };
    });
```

### Network Security

- Services communicate over encrypted connections
- Network policies restrict inter-service communication
- Rate limiting prevents abuse

### SGX Integration

Services that require secure computation use Intel SGX:

```csharp
// SGX enclave integration
services.AddSingleton<IEnclaveManager, EnclaveManager>();
services.Configure<EnclaveOptions>(options =>
{
    options.Mode = Environment.GetEnvironmentVariable("SGX_MODE") ?? "SIM";
});
```

## Deployment

### Development Deployment

```bash
# Start all services in development mode
./scripts/deploy-microservices.sh

# Start specific services
docker-compose -f docker-compose.microservices-complete.yml up -d notification-service configuration-service
```

### Production Deployment

```bash
# Set production environment
export ASPNETCORE_ENVIRONMENT=Production
export SGX_MODE=HW

# Deploy with production settings
PULL_IMAGES=true ./scripts/deploy-microservices.sh
```

### Kubernetes Deployment

Kubernetes manifests are provided for container orchestration:

```bash
# Deploy to Kubernetes
kubectl apply -f k8s/namespace.yaml
kubectl apply -f k8s/configmap.yaml
kubectl apply -f k8s/services/
kubectl apply -f k8s/deployments/
```

## Troubleshooting

### Common Issues

1. **Service Discovery Issues**
   ```bash
   # Check Consul health
   curl http://localhost:8500/v1/status/leader
   
   # View registered services
   curl http://localhost:8500/v1/catalog/services
   ```

2. **Database Connection Issues**
   ```bash
   # Check PostgreSQL health
   docker-compose exec postgres pg_isready -U neouser
   
   # View database logs
   docker-compose logs postgres
   ```

3. **Service Health Issues**
   ```bash
   # Check service health
   curl http://localhost:5010/health
   
   # View service logs
   docker-compose logs notification-service
   ```

### Performance Tuning

1. **Resource Limits**
   ```yaml
   # Adjust container resources
   deploy:
     resources:
       limits:
         memory: 1024M
         cpus: '1.0'
       reservations:
         memory: 512M
         cpus: '0.5'
   ```

2. **Database Connection Pooling**
   ```csharp
   // Configure connection pooling
   services.AddDbContext<ApplicationDbContext>(options =>
   {
       options.UseNpgsql(connectionString, npgsqlOptions =>
       {
           npgsqlOptions.CommandTimeout(30);
       });
   });
   ```

### Monitoring and Alerting

1. **Prometheus Alerts**
   ```yaml
   # High error rate alert
   - alert: HighErrorRate
     expr: rate(service_requests_total{status="failed"}[5m]) > 0.1
     for: 5m
     labels:
       severity: critical
     annotations:
       summary: "High error rate detected"
   ```

2. **Grafana Dashboards**
   - Service performance dashboard
   - Infrastructure monitoring dashboard
   - Business metrics dashboard

## API Documentation

### Service Endpoints

Each service exposes RESTful APIs:

#### Notification Service
- `POST /api/notifications/send` - Send notification
- `GET /api/notifications/templates` - Get templates
- `GET /api/notifications/history` - Get history

#### Smart Contracts Service
- `POST /api/smart-contracts/deploy` - Deploy contract
- `POST /api/smart-contracts/invoke` - Invoke contract
- `GET /api/smart-contracts/state/{hash}` - Get contract state

#### Cross Chain Service
- `POST /api/cross-chain/transfer` - Initiate transfer
- `GET /api/cross-chain/transfer/{id}` - Get transfer status
- `GET /api/cross-chain/chains` - Get supported chains

### API Gateway Routes

All service APIs are accessible through the gateway:

```
http://localhost:5000/api/notifications/*  -> notification-service
http://localhost:5000/api/smart-contracts/* -> smart-contracts-service
http://localhost:5000/api/cross-chain/*    -> cross-chain-service
```

## Development

### Adding New Services

1. Create service project structure
2. Implement service interface
3. Add Docker configuration
4. Update docker-compose.yml
5. Add service registration

### Testing

```bash
# Run unit tests
dotnet test

# Run integration tests
./scripts/run-integration-tests.sh

# Run load tests
./scripts/run-load-tests.sh
```

### Local Development

```bash
# Start dependencies only
docker-compose up -d consul postgres redis rabbitmq

# Run services locally
dotnet run --project src/Services/NeoServiceLayer.Services.Notification
```

## Contributing

1. Follow the existing code patterns
2. Add appropriate tests
3. Update documentation
4. Ensure all health checks pass
5. Add monitoring and logging

## License

This project is licensed under the MIT License - see the LICENSE file for details.