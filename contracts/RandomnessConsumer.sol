// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "./ServiceRegistry.sol";

/**
 * @title RandomnessConsumer
 * @dev Contract for consuming randomness from Neo Service Layer Randomness Service
 * @notice This contract provides secure random number generation using the Neo Service Layer
 */
contract RandomnessConsumer is Ownable, ReentrancyGuard {
    
    ServiceRegistry public immutable serviceRegistry;
    bytes32 public immutable randomnessServiceId;
    
    struct RandomnessRequest {
        address requester;
        uint256 min;
        uint256 max;
        uint256 requestedAt;
        bool fulfilled;
        uint256 randomValue;
        uint256 fulfilledAt;
    }
    
    // Request ID => RandomnessRequest
    mapping(bytes32 => RandomnessRequest) public randomnessRequests;
    
    // Requester => Request IDs
    mapping(address => bytes32[]) public userRequests;
    
    // Array of all request IDs
    bytes32[] public allRequestIds;
    
    // Events
    event RandomnessRequested(
        bytes32 indexed requestId,
        address indexed requester,
        uint256 min,
        uint256 max
    );
    
    event RandomnessFulfilled(
        bytes32 indexed requestId,
        address indexed requester,
        uint256 randomValue
    );
    
    // Modifiers
    modifier validRange(uint256 min, uint256 max) {
        require(min < max, "Invalid range: min must be less than max");
        require(max - min <= 1000000, "Range too large");
        _;
    }
    
    modifier requestExists(bytes32 requestId) {
        require(randomnessRequests[requestId].requester != address(0), "Request does not exist");
        _;
    }
    
    modifier requestNotFulfilled(bytes32 requestId) {
        require(!randomnessRequests[requestId].fulfilled, "Request already fulfilled");
        _;
    }
    
    constructor(address _serviceRegistry, bytes32 _randomnessServiceId) {
        require(_serviceRegistry != address(0), "Service registry cannot be zero address");
        serviceRegistry = ServiceRegistry(_serviceRegistry);
        randomnessServiceId = _randomnessServiceId;
    }
    
    /**
     * @dev Requests a random number within the specified range
     * @param min The minimum value (inclusive)
     * @param max The maximum value (exclusive)
     * @return requestId The unique identifier for this randomness request
     */
    function requestRandomness(uint256 min, uint256 max) 
        external 
        validRange(min, max) 
        nonReentrant 
        returns (bytes32) 
    {
        // Verify randomness service is active
        require(serviceRegistry.isServiceActive(randomnessServiceId), "Randomness service is not active");
        
        bytes32 requestId = keccak256(abi.encodePacked(
            msg.sender,
            min,
            max,
            block.timestamp,
            block.difficulty,
            allRequestIds.length
        ));
        
        randomnessRequests[requestId] = RandomnessRequest({
            requester: msg.sender,
            min: min,
            max: max,
            requestedAt: block.timestamp,
            fulfilled: false,
            randomValue: 0,
            fulfilledAt: 0
        });
        
        userRequests[msg.sender].push(requestId);
        allRequestIds.push(requestId);
        
        // Log the request in the service registry for metrics
        serviceRegistry.logServiceRequest(randomnessServiceId, true);
        
        emit RandomnessRequested(requestId, msg.sender, min, max);
        
        return requestId;
    }
    
    /**
     * @dev Fulfills a randomness request (called by the Neo Service Layer)
     * @param requestId The ID of the request to fulfill
     * @param randomValue The random value generated by the service
     */
    function fulfillRandomness(bytes32 requestId, uint256 randomValue) 
        external 
        onlyOwner 
        requestExists(requestId) 
        requestNotFulfilled(requestId) 
    {
        RandomnessRequest storage request = randomnessRequests[requestId];
        
        // Validate the random value is within the requested range
        require(randomValue >= request.min && randomValue < request.max, "Random value out of range");
        
        request.fulfilled = true;
        request.randomValue = randomValue;
        request.fulfilledAt = block.timestamp;
        
        emit RandomnessFulfilled(requestId, request.requester, randomValue);
    }
    
    /**
     * @dev Gets the result of a randomness request
     * @param requestId The ID of the request
     * @return fulfilled Whether the request has been fulfilled
     * @return randomValue The random value (0 if not fulfilled)
     */
    function getRandomnessResult(bytes32 requestId) 
        external 
        view 
        requestExists(requestId) 
        returns (bool fulfilled, uint256 randomValue) 
    {
        RandomnessRequest memory request = randomnessRequests[requestId];
        return (request.fulfilled, request.randomValue);
    }
    
    /**
     * @dev Gets all request IDs for a user
     * @param user The address of the user
     * @return Array of request IDs
     */
    function getUserRequests(address user) external view returns (bytes32[] memory) {
        return userRequests[user];
    }
    
    /**
     * @dev Gets the total number of randomness requests
     * @return The number of requests
     */
    function getRequestCount() external view returns (uint256) {
        return allRequestIds.length;
    }
    
    /**
     * @dev Gets request details
     * @param requestId The ID of the request
     * @return RandomnessRequest struct containing request details
     */
    function getRequest(bytes32 requestId) external view returns (RandomnessRequest memory) {
        return randomnessRequests[requestId];
    }
    
    /**
     * @dev Batch request multiple random numbers
     * @param min Array of minimum values
     * @param max Array of maximum values
     * @return requestIds Array of request IDs
     */
    function batchRequestRandomness(uint256[] memory min, uint256[] memory max) 
        external 
        nonReentrant 
        returns (bytes32[] memory) 
    {
        require(min.length == max.length, "Arrays length mismatch");
        require(min.length > 0 && min.length <= 10, "Invalid batch size");
        
        bytes32[] memory requestIds = new bytes32[](min.length);
        
        for (uint256 i = 0; i < min.length; i++) {
            require(min[i] < max[i], "Invalid range");
            require(max[i] - min[i] <= 1000000, "Range too large");
            
            bytes32 requestId = keccak256(abi.encodePacked(
                msg.sender,
                min[i],
                max[i],
                block.timestamp,
                block.difficulty,
                allRequestIds.length + i
            ));
            
            randomnessRequests[requestId] = RandomnessRequest({
                requester: msg.sender,
                min: min[i],
                max: max[i],
                requestedAt: block.timestamp,
                fulfilled: false,
                randomValue: 0,
                fulfilledAt: 0
            });
            
            userRequests[msg.sender].push(requestId);
            allRequestIds.push(requestId);
            requestIds[i] = requestId;
            
            emit RandomnessRequested(requestId, msg.sender, min[i], max[i]);
        }
        
        // Log the batch request in the service registry
        serviceRegistry.logServiceRequest(randomnessServiceId, true);
        
        return requestIds;
    }
    
    /**
     * @dev Emergency function to cancel unfulfilled requests older than 1 hour
     * @param requestId The ID of the request to cancel
     */
    function cancelExpiredRequest(bytes32 requestId) 
        external 
        requestExists(requestId) 
        requestNotFulfilled(requestId) 
    {
        RandomnessRequest storage request = randomnessRequests[requestId];
        require(msg.sender == request.requester || msg.sender == owner(), "Not authorized");
        require(block.timestamp > request.requestedAt + 1 hours, "Request not expired");
        
        request.fulfilled = true; // Mark as fulfilled to prevent further processing
        request.randomValue = 0;
        request.fulfilledAt = block.timestamp;
    }
}
