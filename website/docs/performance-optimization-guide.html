<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance Optimization Guide - Neo Service Layer</title>
    <meta name="description" content="Enterprise performance optimization guide for Neo Service Layer with benchmarks, profiling techniques, caching strategies, database optimization, and production tuning best practices.">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://docs.neoservicelayer.com/performance-optimization">
    <meta property="og:title" content="Neo Service Layer Performance Optimization Guide">
    <meta property="og:description" content="Complete guide for optimizing Neo Service Layer performance in production environments">
    <meta property="og:image" content="https://docs.neoservicelayer.com/images/performance-guide-og.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://docs.neoservicelayer.com/performance-optimization">
    <meta property="twitter:title" content="Neo Service Layer Performance Optimization Guide">
    <meta property="twitter:description" content="Complete guide for performance optimization and production tuning">
    <meta property="twitter:image" content="https://docs.neoservicelayer.com/images/performance-guide-twitter.png">

    <!-- Canonical URL -->
    <link rel="canonical" href="https://docs.neoservicelayer.com/performance-optimization">
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="../public/favicon.svg">
    <link rel="icon" type="image/png" href="../public/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="../public/favicon-16x16.png" sizes="16x16">
    <link rel="apple-touch-icon" href="../public/apple-touch-icon.png">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- CSS -->
    <link rel="stylesheet" href="../src/styles/design-system.css">
    <link rel="stylesheet" href="../src/styles/docs-professional.css">
    <link rel="stylesheet" href="../src/styles/code-playground.css">
    <link rel="stylesheet" href="../src/styles/docs-search.css">
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@tabler/icons@2.40.0/tabler-icons.min.css">
    
    <!-- Code Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-one-light.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css">
    
    <!-- Chart.js for performance graphs -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    
    <!-- Performance Guide Specific Styles -->
    <style>
        .performance-dashboard {
            background: var(--docs-bg-secondary);
            border: 1px solid var(--docs-border-light);
            border-radius: 12px;
            padding: 24px;
            margin: 32px 0;
        }
        
        .benchmark-results {
            background: var(--docs-bg-primary);
            border: 1px solid var(--docs-border-light);
            border-radius: 8px;
            padding: 20px;
            margin: 16px 0;
            overflow-x: auto;
        }
        
        .benchmark-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        
        .benchmark-table th {
            background: var(--docs-bg-tertiary);
            padding: 12px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid var(--docs-border-light);
        }
        
        .benchmark-table td {
            padding: 12px;
            border-bottom: 1px solid var(--docs-border-light);
        }
        
        .benchmark-table tr:last-child td {
            border-bottom: none;
        }
        
        .performance-metric {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .metric-excellent {
            background: rgba(34, 197, 94, 0.1);
            color: #22c55e;
        }
        
        .metric-good {
            background: rgba(59, 130, 246, 0.1);
            color: #3b82f6;
        }
        
        .metric-warning {
            background: rgba(251, 191, 36, 0.1);
            color: #f59e0b;
        }
        
        .metric-poor {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
        }
        
        .optimization-technique {
            background: var(--docs-bg-secondary);
            border: 1px solid var(--docs-border-light);
            border-radius: 12px;
            padding: 24px;
            margin: 24px 0;
        }
        
        .technique-header {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 20px;
        }
        
        .technique-icon {
            width: 48px;
            height: 48px;
            background: var(--docs-accent-blue);
            color: white;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .technique-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--docs-text-primary);
            margin: 0;
        }
        
        .technique-impact {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 8px;
            background: var(--docs-bg-tertiary);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 14px;
        }
        
        .impact-high {
            color: #22c55e;
        }
        
        .impact-medium {
            color: #3b82f6;
        }
        
        .impact-low {
            color: #f59e0b;
        }
        
        .profiling-results {
            background: var(--docs-bg-primary);
            border: 1px solid var(--docs-border-light);
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
        }
        
        .flame-graph {
            width: 100%;
            height: 400px;
            background: var(--docs-bg-secondary);
            border: 1px solid var(--docs-border-light);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--docs-text-secondary);
            font-style: italic;
        }
        
        .performance-chart-container {
            background: var(--docs-bg-primary);
            border: 1px solid var(--docs-border-light);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            height: 400px;
        }
        
        .cache-strategy-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .cache-strategy-card {
            background: var(--docs-bg-primary);
            border: 1px solid var(--docs-border-light);
            border-radius: 8px;
            padding: 20px;
        }
        
        .cache-strategy-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }
        
        .cache-strategy-icon {
            width: 32px;
            height: 32px;
            background: var(--docs-bg-tertiary);
            color: var(--docs-accent-blue);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .cache-strategy-title {
            font-weight: 600;
            color: var(--docs-text-primary);
            margin: 0;
        }
        
        .optimization-before-after {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .code-comparison {
            background: var(--docs-bg-primary);
            border: 1px solid var(--docs-border-light);
            border-radius: 8px;
            overflow: hidden;
        }
        
        .code-comparison-header {
            background: var(--docs-bg-tertiary);
            padding: 12px 16px;
            font-weight: 600;
            font-size: 14px;
            border-bottom: 1px solid var(--docs-border-light);
        }
        
        .code-comparison-header.before {
            color: #ef4444;
        }
        
        .code-comparison-header.after {
            color: #22c55e;
        }
        
        .tuning-parameter {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px;
            background: var(--docs-bg-primary);
            border: 1px solid var(--docs-border-light);
            border-radius: 8px;
            margin: 12px 0;
        }
        
        .parameter-info {
            flex: 1;
        }
        
        .parameter-name {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            color: var(--docs-text-primary);
            margin: 0 0 4px 0;
        }
        
        .parameter-description {
            font-size: 14px;
            color: var(--docs-text-secondary);
            margin: 0;
        }
        
        .parameter-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            background: var(--docs-bg-tertiary);
            padding: 6px 12px;
            border-radius: 6px;
            color: var(--docs-accent-blue);
        }
    </style>
</head>
<body class="performance-guide-page">
    <!-- Documentation Header -->
    <header class="docs-header-nav performance-header">
        <div class="docs-header-container">
            <div class="docs-header-left">
                <a href="/" class="docs-brand">
                    <div class="docs-brand-icon">⚡</div>
                    <div class="docs-brand-text">
                        <div class="docs-brand-name">Neo Service Layer</div>
                        <div class="docs-brand-subtitle">Performance Optimization Guide</div>
                    </div>
                </a>
                
                <div class="performance-stats">
                    <div class="stat-item">
                        <span class="stat-value">1.2ms</span>
                        <span class="stat-label">Avg Response</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value">50k</span>
                        <span class="stat-label">Req/sec</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value">99.99%</span>
                        <span class="stat-label">Uptime</span>
                    </div>
                </div>
            </div>
            
            <div class="docs-header-center">
                <div class="docs-search-container">
                    <div class="docs-search-input-wrapper">
                        <i class="ti ti-search docs-search-icon"></i>
                        <input 
                            type="text" 
                            placeholder="Search performance optimizations..." 
                            class="docs-search-input"
                            id="docs-search"
                        >
                        <div class="docs-search-shortcut">
                            <kbd>⌘</kbd><kbd>K</kbd>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="docs-header-right">
                <button class="docs-theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <i class="ti ti-sun docs-theme-icon-light"></i>
                    <i class="ti ti-moon docs-theme-icon-dark"></i>
                </button>
                
                <a href="https://github.com/neo-service-layer" class="docs-github-link" target="_blank" rel="noopener">
                    <i class="ti ti-brand-github"></i>
                </a>
                
                <a href="/app.html" class="docs-cta-button">
                    Try Live Demo
                    <i class="ti ti-external-link"></i>
                </a>
                
                <button class="docs-mobile-menu-toggle" id="mobile-menu-toggle" aria-label="Toggle navigation">
                    <i class="ti ti-menu-2"></i>
                </button>
            </div>
        </div>
    </header>

    <!-- Documentation Container -->
    <div class="docs-container">
        <!-- Sidebar Navigation -->
        <nav class="docs-sidebar" id="docs-sidebar">
            <div class="docs-sidebar-header">
                <h3 class="docs-sidebar-title">Performance Guide</h3>
                <div class="docs-sidebar-version">
                    <span class="version-badge">v1.5.2</span>
                    <span>Production</span>
                </div>
            </div>
            
            <div class="docs-nav">
                <!-- Overview -->
                <div class="docs-nav-section">
                    <h4 class="docs-nav-section-title">Overview</h4>
                    <ul class="docs-nav-list">
                        <li class="docs-nav-item">
                            <a href="#introduction" class="docs-nav-link active">
                                <i class="ti ti-info-circle"></i>
                                Introduction
                            </a>
                        </li>
                        <li class="docs-nav-item">
                            <a href="#benchmarks" class="docs-nav-link">
                                <i class="ti ti-chart-bar"></i>
                                Performance Benchmarks
                            </a>
                        </li>
                        <li class="docs-nav-item">
                            <a href="#profiling" class="docs-nav-link">
                                <i class="ti ti-microscope"></i>
                                Profiling & Analysis
                            </a>
                        </li>
                        <li class="docs-nav-item">
                            <a href="#monitoring" class="docs-nav-link">
                                <i class="ti ti-activity"></i>
                                Monitoring Setup
                            </a>
                        </li>
                    </ul>
                </div>

                <!-- Optimization Techniques -->
                <div class="docs-nav-section">
                    <h4 class="docs-nav-section-title">Optimization Techniques</h4>
                    <ul class="docs-nav-list">
                        <li class="docs-nav-item">
                            <a href="#api-optimization" class="docs-nav-link">
                                <i class="ti ti-api"></i>
                                API Layer Optimization
                            </a>
                        </li>
                        <li class="docs-nav-item">
                            <a href="#database-optimization" class="docs-nav-link">
                                <i class="ti ti-database"></i>
                                Database Optimization
                            </a>
                        </li>
                        <li class="docs-nav-item">
                            <a href="#caching-strategies" class="docs-nav-link">
                                <i class="ti ti-server"></i>
                                Caching Strategies
                            </a>
                        </li>
                        <li class="docs-nav-item">
                            <a href="#connection-pooling" class="docs-nav-link">
                                <i class="ti ti-git-merge"></i>
                                Connection Pooling
                            </a>
                        </li>
                        <li class="docs-nav-item">
                            <a href="#async-processing" class="docs-nav-link">
                                <i class="ti ti-clock"></i>
                                Async Processing
                            </a>
                        </li>
                        <li class="docs-nav-item">
                            <a href="#sgx-optimization" class="docs-nav-link">
                                <i class="ti ti-cpu"></i>
                                Intel SGX Optimization
                            </a>
                        </li>
                    </ul>
                </div>

                <!-- Infrastructure -->
                <div class="docs-nav-section">
                    <h4 class="docs-nav-section-title">Infrastructure</h4>
                    <ul class="docs-nav-list">
                        <li class="docs-nav-item">
                            <a href="#kubernetes-tuning" class="docs-nav-link">
                                <i class="ti ti-brand-docker"></i>
                                Kubernetes Tuning
                            </a>
                        </li>
                        <li class="docs-nav-item">
                            <a href="#network-optimization" class="docs-nav-link">
                                <i class="ti ti-network"></i>
                                Network Optimization
                            </a>
                        </li>
                        <li class="docs-nav-item">
                            <a href="#load-balancing" class="docs-nav-link">
                                <i class="ti ti-scale"></i>
                                Load Balancing
                            </a>
                        </li>
                        <li class="docs-nav-item">
                            <a href="#auto-scaling" class="docs-nav-link">
                                <i class="ti ti-arrows-maximize"></i>
                                Auto Scaling
                            </a>
                        </li>
                    </ul>
                </div>

                <!-- Best Practices -->
                <div class="docs-nav-section">
                    <h4 class="docs-nav-section-title">Best Practices</h4>
                    <ul class="docs-nav-list">
                        <li class="docs-nav-item">
                            <a href="#code-optimization" class="docs-nav-link">
                                <i class="ti ti-code"></i>
                                Code Optimization
                            </a>
                        </li>
                        <li class="docs-nav-item">
                            <a href="#testing-performance" class="docs-nav-link">
                                <i class="ti ti-test-pipe"></i>
                                Performance Testing
                            </a>
                        </li>
                        <li class="docs-nav-item">
                            <a href="#troubleshooting" class="docs-nav-link">
                                <i class="ti ti-tool"></i>
                                Troubleshooting
                            </a>
                        </li>
                        <li class="docs-nav-item">
                            <a href="#checklists" class="docs-nav-link">
                                <i class="ti ti-checklist"></i>
                                Optimization Checklists
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </nav>

        <!-- Main Content -->
        <main class="docs-main">
            <!-- Introduction Section -->
            <section id="introduction" class="docs-section">
                <div class="section-header">
                    <h1 class="section-title">Performance Optimization Guide</h1>
                    <div class="section-meta">
                        <span class="section-badge">Enterprise Grade</span>
                        <span class="section-version">v1.5.2</span>
                        <span class="section-update">Updated Jan 30, 2025</span>
                    </div>
                </div>

                <div class="section-content">
                    <div class="section-intro">
                        <p class="lead">
                            Comprehensive guide for optimizing Neo Service Layer performance in production environments. 
                            Learn how to achieve sub-millisecond response times, handle 50,000+ requests per second, 
                            and maintain 99.99% uptime through proven optimization techniques.
                        </p>
                    </div>

                    <!-- Performance Goals -->
                    <div class="performance-goals">
                        <h3>Performance Targets</h3>
                        <div class="goals-grid">
                            <div class="goal-card">
                                <div class="goal-icon">
                                    <i class="ti ti-clock"></i>
                                </div>
                                <h4>Response Time</h4>
                                <div class="goal-metric">< 10ms</div>
                                <p>P99 latency under 10ms for all API endpoints</p>
                            </div>
                            
                            <div class="goal-card">
                                <div class="goal-icon">
                                    <i class="ti ti-trending-up"></i>
                                </div>
                                <h4>Throughput</h4>
                                <div class="goal-metric">50k req/s</div>
                                <p>Handle 50,000+ requests per second at peak</p>
                            </div>
                            
                            <div class="goal-card">
                                <div class="goal-icon">
                                    <i class="ti ti-chart-line"></i>
                                </div>
                                <h4>Availability</h4>
                                <div class="goal-metric">99.99%</div>
                                <p>Less than 4.38 minutes downtime per month</p>
                            </div>
                            
                            <div class="goal-card">
                                <div class="goal-icon">
                                    <i class="ti ti-cpu"></i>
                                </div>
                                <h4>Resource Efficiency</h4>
                                <div class="goal-metric">< 70%</div>
                                <p>CPU usage under 70% at peak load</p>
                            </div>
                        </div>
                    </div>

                    <!-- Performance Architecture -->
                    <div class="performance-architecture">
                        <h3>High-Performance Architecture</h3>
                        <div class="architecture-diagram">
                            <pre class="architecture-ascii">
┌─────────────────────────────────────────────────────────────────────────────┐
│                          Performance Architecture                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Client Tier          Edge Tier            Service Tier       Data Tier    │
│  ┌─────────┐         ┌─────────┐          ┌─────────┐       ┌─────────┐  │
│  │         │         │   CDN   │          │  Load   │       │  Redis  │  │
│  │ Browser ├────────▶│ (Global)├─────────▶│Balancer ├──────▶│ Cluster │  │
│  │         │         └─────────┘          └────┬────┘       └─────────┘  │
│  └─────────┘                                   │                          │
│                      ┌─────────┐               │            ┌─────────┐  │
│  ┌─────────┐         │  Edge   │               ▼            │Postgres │  │
│  │ Mobile  ├────────▶│ Cache   ├──────▶┌──────────────┐    │ Primary │  │
│  │   App   │         │ (Redis) │       │ API Gateway  │    └─────────┘  │
│  └─────────┘         └─────────┘       │  (Kong/Envoy)│                  │
│                                        └──────┬───────┘    ┌─────────┐  │
│  ┌─────────┐         ┌─────────┐              │            │Postgres │  │
│  │   SDK   ├────────▶│  Rate   ├──────────────┼───────────▶│Replicas │  │
│  │         │         │ Limiter │              │            └─────────┘  │
│  └─────────┘         └─────────┘              ▼                          │
│                                        ┌──────────────┐    ┌─────────┐  │
│                                        │  Service     │    │  S3     │  │
│                                        │  Mesh        ├───▶│ Storage │  │
│                                        │  (Istio)     │    └─────────┘  │
│                                        └──────┬───────┘                  │
│                                               │                          │
│                      ┌────────────────────────┴─────────────────┐        │
│                      │         Microservices Layer              │        │
│                      │                                          │        │
│                      │  ┌──────────┐  ┌──────────┐  ┌────────┐ │        │
│                      │  │ Storage  │  │Identity  │  │Oracle  │ │        │
│                      │  │ Service  │  │ Service  │  │Service │ │        │
│                      │  │(3 pods)  │  │(3 pods)  │  │(3 pods)│ │        │
│                      │  └──────────┘  └──────────┘  └────────┘ │        │
│                      │                                          │        │
│                      │  ┌──────────┐  ┌──────────┐  ┌────────┐ │        │
│                      │  │ Compute  │  │  Trans-  │  │  NFT   │ │        │
│                      │  │ Service  │  │  action  │  │Service │ │        │
│                      │  │(5 pods)  │  │(5 pods)  │  │(3 pods)│ │        │
│                      │  └──────────┘  └──────────┘  └────────┘ │        │
│                      └──────────────────────────────────────────┘        │
│                                                                           │
└───────────────────────────────────────────────────────────────────────────┘
                            </pre>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Performance Benchmarks Section -->
            <section id="benchmarks" class="docs-section">
                <div class="section-header">
                    <h2 class="section-title">Performance Benchmarks</h2>
                    <div class="section-meta">
                        <span class="section-badge">Production Metrics</span>
                    </div>
                </div>

                <div class="section-content">
                    <div class="performance-dashboard">
                        <h3>Current Production Performance</h3>
                        <p>Real-world benchmarks from production environment handling 2M+ daily requests:</p>
                        
                        <!-- Response Time Distribution -->
                        <div class="performance-chart-container">
                            <canvas id="responseTimeChart"></canvas>
                        </div>
                        
                        <!-- Service-by-Service Benchmarks -->
                        <div class="benchmark-results">
                            <h4>Service Performance Breakdown</h4>
                            <table class="benchmark-table">
                                <thead>
                                    <tr>
                                        <th>Service</th>
                                        <th>Avg Response</th>
                                        <th>P50</th>
                                        <th>P95</th>
                                        <th>P99</th>
                                        <th>Throughput</th>
                                        <th>Error Rate</th>
                                        <th>Status</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>Storage Service</strong></td>
                                        <td><span class="performance-metric metric-excellent">0.8ms</span></td>
                                        <td>0.7ms</td>
                                        <td>1.2ms</td>
                                        <td>2.1ms</td>
                                        <td>12,000 req/s</td>
                                        <td><span class="performance-metric metric-excellent">0.001%</span></td>
                                        <td>✅ Optimal</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Identity Service</strong></td>
                                        <td><span class="performance-metric metric-excellent">1.1ms</span></td>
                                        <td>0.9ms</td>
                                        <td>1.8ms</td>
                                        <td>3.2ms</td>
                                        <td>8,500 req/s</td>
                                        <td><span class="performance-metric metric-excellent">0.002%</span></td>
                                        <td>✅ Optimal</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Oracle Service</strong></td>
                                        <td><span class="performance-metric metric-good">2.3ms</span></td>
                                        <td>1.9ms</td>
                                        <td>3.8ms</td>
                                        <td>5.1ms</td>
                                        <td>5,200 req/s</td>
                                        <td><span class="performance-metric metric-good">0.01%</span></td>
                                        <td>✅ Good</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Compute Service</strong></td>
                                        <td><span class="performance-metric metric-warning">5.2ms</span></td>
                                        <td>4.1ms</td>
                                        <td>12.3ms</td>
                                        <td>15.8ms</td>
                                        <td>3,800 req/s</td>
                                        <td><span class="performance-metric metric-good">0.02%</span></td>
                                        <td>⚠️ Monitor</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Transaction Service</strong></td>
                                        <td><span class="performance-metric metric-excellent">1.5ms</span></td>
                                        <td>1.2ms</td>
                                        <td>2.8ms</td>
                                        <td>4.2ms</td>
                                        <td>15,000 req/s</td>
                                        <td><span class="performance-metric metric-excellent">0.001%</span></td>
                                        <td>✅ Optimal</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Smart Contract Service</strong></td>
                                        <td><span class="performance-metric metric-good">3.1ms</span></td>
                                        <td>2.5ms</td>
                                        <td>5.8ms</td>
                                        <td>8.9ms</td>
                                        <td>6,500 req/s</td>
                                        <td><span class="performance-metric metric-good">0.015%</span></td>
                                        <td>✅ Good</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <!-- Load Test Results -->
                        <div class="benchmark-results">
                            <h4>Load Test Results</h4>
                            <p>Results from stress testing with 100k concurrent connections:</p>
                            <div class="code-playground">
                                <code class="language-bash">
# Load test configuration
wrk -t12 -c100000 -d300s --latency \
    -H "Authorization: Bearer $API_KEY" \
    https://api.neoservicelayer.com/storage/get?key=test

# Results
Running 5m test @ https://api.neoservicelayer.com/storage/get
  12 threads and 100000 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency     1.23ms  894.21us  52.31ms   92.45%
    Req/Sec     4.21k    512.38     5.82k    89.17%
  Latency Distribution
     50%    0.98ms
     75%    1.42ms
     90%    2.01ms
     99%    4.52ms
  15,123,847 requests in 5.00m, 4.21GB read
  Socket errors: connect 0, read 0, write 0, timeout 0
Requests/sec:  50,412.82
Transfer/sec:     14.37MB
                                </code>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Profiling Section -->
            <section id="profiling" class="docs-section">
                <div class="section-header">
                    <h2 class="section-title">Profiling & Analysis</h2>
                    <div class="section-meta">
                        <span class="section-badge">Advanced</span>
                    </div>
                </div>

                <div class="section-content">
                    <div class="profiling-guide">
                        <h3>Production Profiling Tools</h3>
                        
                        <!-- CPU Profiling -->
                        <div class="optimization-technique">
                            <div class="technique-header">
                                <div class="technique-icon">
                                    <i class="ti ti-cpu"></i>
                                </div>
                                <h4 class="technique-title">CPU Profiling</h4>
                                <div class="technique-impact impact-high">
                                    <i class="ti ti-trending-up"></i>
                                    High Impact
                                </div>
                            </div>
                            
                            <p>Use pprof for Go services to identify CPU bottlenecks:</p>
                            <div class="code-playground">
                                <code class="language-go">
// Enable pprof endpoints in your service
import (
    _ "net/http/pprof"
    "net/http"
)

func main() {
    // Enable pprof
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
    
    // Your service code...
}

// Profile CPU usage
// Terminal 1: Generate load
// Terminal 2: Capture profile
go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30

// Analyze with web UI
go tool pprof -http=:8080 profile.pb.gz
                                </code>
                            </div>
                            
                            <div class="profiling-results">
                                <h5>Common CPU Bottlenecks Found</h5>
                                <ul>
                                    <li><strong>JSON marshaling/unmarshaling:</strong> 28% CPU time - Optimized with easyjson</li>
                                    <li><strong>Regex compilation:</strong> 15% CPU time - Fixed with pre-compiled regex</li>
                                    <li><strong>Reflection usage:</strong> 12% CPU time - Replaced with code generation</li>
                                    <li><strong>String concatenation:</strong> 8% CPU time - Used strings.Builder</li>
                                </ul>
                            </div>
                        </div>

                        <!-- Memory Profiling -->
                        <div class="optimization-technique">
                            <div class="technique-header">
                                <div class="technique-icon">
                                    <i class="ti ti-cpu-2"></i>
                                </div>
                                <h4 class="technique-title">Memory Profiling</h4>
                                <div class="technique-impact impact-high">
                                    <i class="ti ti-trending-up"></i>
                                    High Impact
                                </div>
                            </div>
                            
                            <p>Identify memory leaks and reduce allocations:</p>
                            <div class="code-playground">
                                <code class="language-go">
// Capture heap profile
curl http://localhost:6060/debug/pprof/heap > heap.pb.gz
go tool pprof heap.pb.gz

// Analyze allocations
go tool pprof -alloc_space http://localhost:6060/debug/pprof/heap

// Find memory leaks
go tool pprof -inuse_space http://localhost:6060/debug/pprof/heap

// Example optimization: Object pooling
var bufferPool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 0, 4096)
    },
}

func processRequest(data []byte) {
    buf := bufferPool.Get().([]byte)
    defer func() {
        buf = buf[:0]
        bufferPool.Put(buf)
    }()
    
    // Use buffer for processing
    buf = append(buf, data...)
    // Process...
}
                                </code>
                            </div>
                        </div>

                        <!-- Distributed Tracing -->
                        <div class="optimization-technique">
                            <div class="technique-header">
                                <div class="technique-icon">
                                    <i class="ti ti-git-branch"></i>
                                </div>
                                <h4 class="technique-title">Distributed Tracing</h4>
                                <div class="technique-impact impact-medium">
                                    <i class="ti ti-trending-up"></i>
                                    Medium Impact
                                </div>
                            </div>
                            
                            <p>Trace requests across microservices with Jaeger:</p>
                            <div class="code-playground">
                                <code class="language-go">
// Initialize Jaeger tracer
import (
    "github.com/uber/jaeger-client-go"
    "github.com/uber/jaeger-client-go/config"
)

func initJaeger(service string) (opentracing.Tracer, io.Closer) {
    cfg := config.Configuration{
        ServiceName: service,
        Sampler: &config.SamplerConfig{
            Type:  jaeger.SamplerTypeConst,
            Param: 1,
        },
        Reporter: &config.ReporterConfig{
            LogSpans:            true,
            BufferFlushInterval: 1 * time.Second,
        },
    }
    
    tracer, closer, err := cfg.NewTracer(
        config.Logger(jaeger.StdLogger),
    )
    if err != nil {
        panic(err)
    }
    
    opentracing.SetGlobalTracer(tracer)
    return tracer, closer
}

// Instrument your code
func handleRequest(ctx context.Context, req Request) Response {
    span, ctx := opentracing.StartSpanFromContext(ctx, "handleRequest")
    defer span.Finish()
    
    // Add tags
    span.SetTag("request.id", req.ID)
    span.SetTag("request.type", req.Type)
    
    // Trace database call
    dbSpan, _ := opentracing.StartSpanFromContext(ctx, "database.query")
    result := queryDatabase(req)
    dbSpan.Finish()
    
    return processResult(result)
}
                                </code>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- API Optimization Section -->
            <section id="api-optimization" class="docs-section">
                <div class="section-header">
                    <h2 class="section-title">API Layer Optimization</h2>
                    <div class="section-meta">
                        <span class="section-badge">High Impact</span>
                    </div>
                </div>

                <div class="section-content">
                    <!-- Request/Response Optimization -->
                    <div class="optimization-technique">
                        <div class="technique-header">
                            <div class="technique-icon">
                                <i class="ti ti-api"></i>
                            </div>
                            <h4 class="technique-title">Request/Response Optimization</h4>
                            <div class="technique-impact impact-high">
                                <i class="ti ti-trending-up"></i>
                                30% Improvement
                            </div>
                        </div>
                        
                        <div class="optimization-before-after">
                            <div class="code-comparison">
                                <div class="code-comparison-header before">❌ Before Optimization</div>
                                <div class="code-playground">
                                    <code class="language-go">
// Inefficient: Multiple database queries
func GetUserProfile(userID string) (*UserProfile, error) {
    user, err := db.GetUser(userID)
    if err != nil {
        return nil, err
    }
    
    // N+1 query problem
    for i, postID := range user.PostIDs {
        post, err := db.GetPost(postID)
        if err != nil {
            return nil, err
        }
        user.Posts[i] = post
    }
    
    // Inefficient JSON handling
    jsonData, err := json.Marshal(user)
    response := &UserProfile{}
    json.Unmarshal(jsonData, response)
    
    return response, nil
}
                                    </code>
                                </div>
                            </div>
                            
                            <div class="code-comparison">
                                <div class="code-comparison-header after">✅ After Optimization</div>
                                <div class="code-playground">
                                    <code class="language-go">
// Optimized: Batch queries and efficient processing
func GetUserProfile(userID string) (*UserProfile, error) {
    // Single query with joins
    query := `
        SELECT u.*, p.*
        FROM users u
        LEFT JOIN posts p ON p.user_id = u.id
        WHERE u.id = $1
    `
    
    rows, err := db.Query(query, userID)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    // Efficient scanning
    profile := &UserProfile{
        Posts: make([]Post, 0, 10), // Pre-allocate
    }
    
    for rows.Next() {
        // Direct scanning, no intermediate JSON
        err := rows.Scan(&profile.ID, &profile.Name, /*...*/)
        if err != nil {
            return nil, err
        }
    }
    
    return profile, nil
}
                                    </code>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Compression -->
                    <div class="optimization-technique">
                        <div class="technique-header">
                            <div class="technique-icon">
                                <i class="ti ti-file-zip"></i>
                            </div>
                            <h4 class="technique-title">Response Compression</h4>
                            <div class="technique-impact impact-medium">
                                <i class="ti ti-trending-up"></i>
                                60% Size Reduction
                            </div>
                        </div>
                        
                        <p>Enable gzip/brotli compression for API responses:</p>
                        <div class="code-playground">
                            <code class="language-go">
// Middleware for compression
import (
    "github.com/gin-contrib/gzip"
    "github.com/gin-gonic/gin"
)

func setupRouter() *gin.Engine {
    r := gin.New()
    
    // Enable gzip compression
    r.Use(gzip.Gzip(gzip.BestSpeed))
    
    // Custom compression for large responses
    r.Use(func(c *gin.Context) {
        c.Next()
        
        // Compress if response > 1KB
        if c.Writer.Size() > 1024 {
            c.Header("Content-Encoding", "gzip")
        }
    })
    
    return r
}

// Brotli for static assets
func serveBrotli(c *gin.Context) {
    path := c.Param("filepath")
    
    // Check if client supports Brotli
    if strings.Contains(c.GetHeader("Accept-Encoding"), "br") {
        // Serve pre-compressed .br file
        c.File(path + ".br")
        c.Header("Content-Encoding", "br")
    } else {
        c.File(path)
    }
}
                            </code>
                        </div>
                    </div>

                    <!-- Pagination and Filtering -->
                    <div class="optimization-technique">
                        <div class="technique-header">
                            <div class="technique-icon">
                                <i class="ti ti-list"></i>
                            </div>
                            <h4 class="technique-title">Efficient Pagination</h4>
                            <div class="technique-impact impact-high">
                                <i class="ti ti-trending-up"></i>
                                90% Faster
                            </div>
                        </div>
                        
                        <p>Implement cursor-based pagination for large datasets:</p>
                        <div class="code-playground">
                            <code class="language-go">
// Cursor-based pagination (efficient for large datasets)
type Cursor struct {
    LastID    string `json:"last_id"`
    Timestamp int64  `json:"timestamp"`
}

func GetTransactions(cursor *Cursor, limit int) (*TransactionPage, error) {
    query := `
        SELECT id, amount, created_at, data
        FROM transactions
        WHERE (created_at, id) > ($1, $2)
        ORDER BY created_at DESC, id DESC
        LIMIT $3
    `
    
    // Default values
    lastTimestamp := int64(0)
    lastID := ""
    if cursor != nil {
        lastTimestamp = cursor.Timestamp
        lastID = cursor.LastID
    }
    
    rows, err := db.Query(query, lastTimestamp, lastID, limit+1)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    transactions := make([]Transaction, 0, limit)
    var hasMore bool
    
    for rows.Next() {
        if len(transactions) >= limit {
            hasMore = true
            break
        }
        
        var tx Transaction
        err := rows.Scan(&tx.ID, &tx.Amount, &tx.CreatedAt, &tx.Data)
        if err != nil {
            return nil, err
        }
        transactions = append(transactions, tx)
    }
    
    // Create next cursor
    var nextCursor *Cursor
    if hasMore && len(transactions) > 0 {
        last := transactions[len(transactions)-1]
        nextCursor = &Cursor{
            LastID:    last.ID,
            Timestamp: last.CreatedAt.Unix(),
        }
    }
    
    return &TransactionPage{
        Transactions: transactions,
        NextCursor:   nextCursor,
        HasMore:      hasMore,
    }, nil
}
                            </code>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Database Optimization Section -->
            <section id="database-optimization" class="docs-section">
                <div class="section-header">
                    <h2 class="section-title">Database Optimization</h2>
                    <div class="section-meta">
                        <span class="section-badge">Critical</span>
                    </div>
                </div>

                <div class="section-content">
                    <!-- Query Optimization -->
                    <div class="optimization-technique">
                        <div class="technique-header">
                            <div class="technique-icon">
                                <i class="ti ti-database"></i>
                            </div>
                            <h4 class="technique-title">Query Optimization</h4>
                            <div class="technique-impact impact-high">
                                <i class="ti ti-trending-up"></i>
                                10x Faster Queries
                            </div>
                        </div>
                        
                        <p>Optimize PostgreSQL queries for production workloads:</p>
                        <div class="code-playground">
                            <code class="language-sql">
-- Create proper indexes
CREATE INDEX CONCURRENTLY idx_transactions_user_created 
ON transactions(user_id, created_at DESC) 
WHERE status = 'completed';

-- Partial index for active records
CREATE INDEX CONCURRENTLY idx_users_active 
ON users(email) 
WHERE deleted_at IS NULL;

-- Composite index for common queries
CREATE INDEX CONCURRENTLY idx_storage_composite 
ON storage_items(key, blockchain_type, created_at DESC)
INCLUDE (value, metadata);

-- Analyze query performance
EXPLAIN (ANALYZE, BUFFERS) 
SELECT s.*, u.name as user_name
FROM storage_items s
JOIN users u ON s.user_id = u.id
WHERE s.blockchain_type = 'NeoN3'
  AND s.created_at > NOW() - INTERVAL '7 days'
ORDER BY s.created_at DESC
LIMIT 100;

-- Optimize with materialized view for complex aggregations
CREATE MATERIALIZED VIEW user_statistics AS
SELECT 
    user_id,
    COUNT(*) as total_transactions,
    SUM(amount) as total_volume,
    AVG(amount) as avg_transaction,
    MAX(created_at) as last_activity
FROM transactions
WHERE status = 'completed'
GROUP BY user_id;

CREATE UNIQUE INDEX ON user_statistics(user_id);

-- Refresh strategy
CREATE OR REPLACE FUNCTION refresh_user_statistics()
RETURNS void AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY user_statistics;
END;
$$ LANGUAGE plpgsql;

-- Schedule refresh
SELECT cron.schedule('refresh-user-stats', '*/5 * * * *', 
    'SELECT refresh_user_statistics()');
                            </code>
                        </div>
                    </div>

                    <!-- Connection Pooling Configuration -->
                    <div class="optimization-technique">
                        <div class="technique-header">
                            <div class="technique-icon">
                                <i class="ti ti-git-merge"></i>
                            </div>
                            <h4 class="technique-title">Connection Pool Tuning</h4>
                            <div class="technique-impact impact-high">
                                <i class="ti ti-trending-up"></i>
                                50% Less Latency
                            </div>
                        </div>
                        
                        <p>Optimize database connection pooling:</p>
                        <div class="code-playground">
                            <code class="language-go">
// Optimal connection pool configuration
import (
    "database/sql"
    "time"
    _ "github.com/lib/pq"
)

func setupDatabasePool() (*sql.DB, error) {
    // Connection string with performance options
    connStr := "postgres://user:pass@localhost/neo?" +
        "sslmode=require&" +
        "connect_timeout=5&" +
        "statement_timeout=30000&" +
        "idle_in_transaction_session_timeout=60000&" +
        "application_name=neo-service-layer"
    
    db, err := sql.Open("postgres", connStr)
    if err != nil {
        return nil, err
    }
    
    // Pool configuration based on workload
    // Formula: connections = ((core_count * 2) + effective_spindle_count)
    db.SetMaxOpenConns(25)              // Maximum connections
    db.SetMaxIdleConns(10)              // Idle connection pool
    db.SetConnMaxLifetime(time.Hour)    // Connection lifetime
    db.SetConnMaxIdleTime(10 * time.Minute) // Idle timeout
    
    // Verify configuration
    if err := db.Ping(); err != nil {
        return nil, err
    }
    
    return db, nil
}

// PgBouncer configuration for production
// pgbouncer.ini
/*
[databases]
neo_db = host=postgres-primary port=5432 dbname=neo

[pgbouncer]
listen_addr = *
listen_port = 6432
auth_type = md5
auth_file = /etc/pgbouncer/userlist.txt
pool_mode = transaction
max_client_conn = 1000
default_pool_size = 25
min_pool_size = 10
reserve_pool_size = 5
reserve_pool_timeout = 3
max_db_connections = 100
max_user_connections = 100
server_lifetime = 3600
server_idle_timeout = 600
*/
                            </code>
                        </div>
                    </div>

                    <!-- Database Sharding -->
                    <div class="optimization-technique">
                        <div class="technique-header">
                            <div class="technique-icon">
                                <i class="ti ti-layers-difference"></i>
                            </div>
                            <h4 class="technique-title">Database Sharding</h4>
                            <div class="technique-impact impact-high">
                                <i class="ti ti-trending-up"></i>
                                Linear Scaling
                            </div>
                        </div>
                        
                        <p>Implement sharding for horizontal scaling:</p>
                        <div class="code-playground">
                            <code class="language-go">
// Consistent hashing for shard distribution
type ShardManager struct {
    shards   []*sql.DB
    replicas map[int][]*sql.DB
    hashRing *consistent.Consistent
}

func NewShardManager(config ShardConfig) (*ShardManager, error) {
    sm := &ShardManager{
        shards:   make([]*sql.DB, config.ShardCount),
        replicas: make(map[int][]*sql.DB),
        hashRing: consistent.New(),
    }
    
    // Initialize shards
    for i := 0; i < config.ShardCount; i++ {
        primary, err := sql.Open("postgres", config.Shards[i].Primary)
        if err != nil {
            return nil, err
        }
        sm.shards[i] = primary
        
        // Add replicas
        for _, replicaURL := range config.Shards[i].Replicas {
            replica, err := sql.Open("postgres", replicaURL)
            if err != nil {
                return nil, err
            }
            sm.replicas[i] = append(sm.replicas[i], replica)
        }
        
        // Add to hash ring
        sm.hashRing.Add(fmt.Sprintf("shard-%d", i))
    }
    
    return sm, nil
}

// Get shard for a key
func (sm *ShardManager) GetShard(key string) *sql.DB {
    shardKey, _ := sm.hashRing.Get(key)
    shardIndex := extractShardIndex(shardKey)
    return sm.shards[shardIndex]
}

// Execute query on correct shard
func (sm *ShardManager) Query(key string, query string, args ...interface{}) (*sql.Rows, error) {
    shard := sm.GetShard(key)
    return shard.Query(query, args...)
}

// Cross-shard query with scatter-gather
func (sm *ShardManager) ScatterGather(query string, aggregator func([]*sql.Rows) error) error {
    var wg sync.WaitGroup
    results := make([]*sql.Rows, len(sm.shards))
    errors := make([]error, len(sm.shards))
    
    for i, shard := range sm.shards {
        wg.Add(1)
        go func(idx int, db *sql.DB) {
            defer wg.Done()
            rows, err := db.Query(query)
            results[idx] = rows
            errors[idx] = err
        }(i, shard)
    }
    
    wg.Wait()
    
    // Check errors
    for _, err := range errors {
        if err != nil {
            return err
        }
    }
    
    return aggregator(results)
}
                            </code>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Caching Strategies Section -->
            <section id="caching-strategies" class="docs-section">
                <div class="section-header">
                    <h2 class="section-title">Caching Strategies</h2>
                    <div class="section-meta">
                        <span class="section-badge">Essential</span>
                    </div>
                </div>

                <div class="section-content">
                    <h3>Multi-Layer Caching Architecture</h3>
                    
                    <div class="cache-strategy-grid">
                        <!-- L1 Cache -->
                        <div class="cache-strategy-card">
                            <div class="cache-strategy-header">
                                <div class="cache-strategy-icon">
                                    <i class="ti ti-cpu"></i>
                                </div>
                                <h4 class="cache-strategy-title">L1: In-Memory Cache</h4>
                            </div>
                            <p>Process-level caching for hot data:</p>
                            <div class="code-playground">
                                <code class="language-go">
// High-performance in-memory cache with TTL
type MemCache struct {
    data sync.Map
    ttl  time.Duration
}

type cacheItem struct {
    value     interface{}
    expiresAt time.Time
}

func (c *MemCache) Get(key string) (interface{}, bool) {
    if item, ok := c.data.Load(key); ok {
        ci := item.(cacheItem)
        if time.Now().Before(ci.expiresAt) {
            return ci.value, true
        }
        c.data.Delete(key)
    }
    return nil, false
}

func (c *MemCache) Set(key string, value interface{}) {
    c.data.Store(key, cacheItem{
        value:     value,
        expiresAt: time.Now().Add(c.ttl),
    })
}

// LRU cache for bounded memory
import "github.com/hashicorp/golang-lru"

func setupLRUCache() *lru.Cache {
    cache, _ := lru.New(10000) // 10k items
    return cache
}
                                </code>
                            </div>
                        </div>

                        <!-- L2 Cache -->
                        <div class="cache-strategy-card">
                            <div class="cache-strategy-header">
                                <div class="cache-strategy-icon">
                                    <i class="ti ti-server"></i>
                                </div>
                                <h4 class="cache-strategy-title">L2: Redis Cache</h4>
                            </div>
                            <p>Distributed caching layer:</p>
                            <div class="code-playground">
                                <code class="language-go">
// Redis cluster configuration
import "github.com/go-redis/redis/v8"

func setupRedisCluster() *redis.ClusterClient {
    return redis.NewClusterClient(&redis.ClusterOptions{
        Addrs: []string{
            "redis-1:6379",
            "redis-2:6379",
            "redis-3:6379",
        },
        Password:     "secret",
        PoolSize:     10,
        MinIdleConns: 5,
        MaxRetries:   3,
        
        // Performance options
        ReadTimeout:  3 * time.Second,
        WriteTimeout: 3 * time.Second,
        DialTimeout:  5 * time.Second,
        
        // Enable pipelining
        MaxRetryBackoff: 512 * time.Millisecond,
    })
}

// Cache-aside pattern with stampede protection
func GetWithCache(ctx context.Context, key string, fetch func() (interface{}, error)) (interface{}, error) {
    // Try cache first
    val, err := redisClient.Get(ctx, key).Result()
    if err == nil {
        var result interface{}
        json.Unmarshal([]byte(val), &result)
        return result, nil
    }
    
    // Use SETNX for stampede protection
    lockKey := key + ":lock"
    locked, err := redisClient.SetNX(ctx, lockKey, "1", 30*time.Second).Result()
    if err != nil || !locked {
        // Wait and retry from cache
        time.Sleep(100 * time.Millisecond)
        return GetWithCache(ctx, key, fetch)
    }
    defer redisClient.Del(ctx, lockKey)
    
    // Fetch from source
    result, err := fetch()
    if err != nil {
        return nil, err
    }
    
    // Cache with TTL
    data, _ := json.Marshal(result)
    redisClient.Set(ctx, key, data, 5*time.Minute)
    
    return result, nil
}
                                </code>
                            </div>
                        </div>

                        <!-- L3 Cache -->
                        <div class="cache-strategy-card">
                            <div class="cache-strategy-header">
                                <div class="cache-strategy-icon">
                                    <i class="ti ti-world"></i>
                                </div>
                                <h4 class="cache-strategy-title">L3: CDN Cache</h4>
                            </div>
                            <p>Edge caching for global distribution:</p>
                            <div class="code-playground">
                                <code class="language-nginx">
# Nginx caching configuration
http {
    # Cache path configuration
    proxy_cache_path /var/cache/nginx 
        levels=1:2 
        keys_zone=neo_cache:100m 
        max_size=10g 
        inactive=60m 
        use_temp_path=off;
    
    # Cache key configuration
    proxy_cache_key "$scheme$request_method$host$request_uri$http_authorization";
    
    server {
        location /api/ {
            # Enable caching
            proxy_cache neo_cache;
            proxy_cache_valid 200 5m;
            proxy_cache_valid 404 1m;
            proxy_cache_use_stale error timeout updating;
            proxy_cache_background_update on;
            proxy_cache_lock on;
            
            # Add cache status header
            add_header X-Cache-Status $upstream_cache_status;
            
            # Cache bypass conditions
            proxy_cache_bypass $http_cache_control;
            proxy_no_cache $http_cache_control;
            
            proxy_pass http://backend;
        }
    }
}
                                </code>
                            </div>
                        </div>
                    </div>

                    <!-- Cache Invalidation -->
                    <div class="optimization-technique">
                        <div class="technique-header">
                            <div class="technique-icon">
                                <i class="ti ti-refresh"></i>
                            </div>
                            <h4 class="technique-title">Cache Invalidation Strategies</h4>
                            <div class="technique-impact impact-high">
                                <i class="ti ti-trending-up"></i>
                                Critical
                            </div>
                        </div>
                        
                        <p>Implement intelligent cache invalidation:</p>
                        <div class="code-playground">
                            <code class="language-go">
// Event-driven cache invalidation
type CacheInvalidator struct {
    redis  *redis.Client
    pubsub *redis.PubSub
}

func (ci *CacheInvalidator) PublishInvalidation(pattern string) error {
    msg := InvalidationMessage{
        Pattern:   pattern,
        Timestamp: time.Now().Unix(),
    }
    
    data, _ := json.Marshal(msg)
    return ci.redis.Publish(ctx, "cache:invalidate", data).Err()
}

func (ci *CacheInvalidator) StartListener() {
    ci.pubsub = ci.redis.Subscribe(ctx, "cache:invalidate")
    ch := ci.pubsub.Channel()
    
    for msg := range ch {
        var invMsg InvalidationMessage
        json.Unmarshal([]byte(msg.Payload), &invMsg)
        
        // Invalidate matching keys
        ci.invalidatePattern(invMsg.Pattern)
    }
}

func (ci *CacheInvalidator) invalidatePattern(pattern string) {
    iter := ci.redis.Scan(ctx, 0, pattern, 1000).Iterator()
    
    pipe := ci.redis.Pipeline()
    count := 0
    
    for iter.Next(ctx) {
        pipe.Del(ctx, iter.Val())
        count++
        
        if count >= 100 {
            pipe.Exec(ctx)
            pipe = ci.redis.Pipeline()
            count = 0
        }
    }
    
    if count > 0 {
        pipe.Exec(ctx)
    }
}

// Smart invalidation with dependencies
type DependencyGraph struct {
    dependencies map[string][]string
    mu           sync.RWMutex
}

func (dg *DependencyGraph) InvalidateCascade(key string) {
    dg.mu.RLock()
    deps := dg.dependencies[key]
    dg.mu.RUnlock()
    
    // Invalidate key and all dependents
    toInvalidate := []string{key}
    toInvalidate = append(toInvalidate, deps...)
    
    for _, k := range toInvalidate {
        cache.Delete(k)
        // Recursively invalidate
        dg.InvalidateCascade(k)
    }
}
                            </code>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Kubernetes Tuning Section -->
            <section id="kubernetes-tuning" class="docs-section">
                <div class="section-header">
                    <h2 class="section-title">Kubernetes Performance Tuning</h2>
                    <div class="section-meta">
                        <span class="section-badge">Infrastructure</span>
                    </div>
                </div>

                <div class="section-content">
                    <!-- Pod Resource Optimization -->
                    <div class="optimization-technique">
                        <div class="technique-header">
                            <div class="technique-icon">
                                <i class="ti ti-brand-docker"></i>
                            </div>
                            <h4 class="technique-title">Pod Resource Optimization</h4>
                            <div class="technique-impact impact-high">
                                <i class="ti ti-trending-up"></i>
                                40% Better Utilization
                            </div>
                        </div>
                        
                        <p>Optimize pod resources based on actual usage:</p>
                        <div class="code-playground">
                            <code class="language-yaml">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: storage-service
spec:
  template:
    spec:
      containers:
      - name: storage-service
        image: neo-service-layer/storage:v1.5.2
        
        # Resource requests/limits based on profiling
        resources:
          requests:
            cpu: "500m"        # 0.5 CPU cores
            memory: "1Gi"      # 1GB RAM
            ephemeral-storage: "1Gi"
          limits:
            cpu: "2000m"       # 2 CPU cores
            memory: "4Gi"      # 4GB RAM
            ephemeral-storage: "2Gi"
            
        # JVM tuning for container environment
        env:
        - name: JAVA_OPTS
          value: >-
            -XX:+UseContainerSupport
            -XX:MaxRAMPercentage=75.0
            -XX:InitialRAMPercentage=50.0
            -XX:+UseG1GC
            -XX:MaxGCPauseMillis=100
            -XX:+ParallelRefProcEnabled
            -XX:+AlwaysPreTouch
            -XX:+UseStringDeduplication
            
        # Readiness/Liveness probes
        readinessProbe:
          httpGet:
            path: /health/ready
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5
          successThreshold: 1
          failureThreshold: 3
          
        livenessProbe:
          httpGet:
            path: /health/live
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
          failureThreshold: 3
          
        # Startup probe for slow starting containers
        startupProbe:
          httpGet:
            path: /health/startup
            port: 8080
          initialDelaySeconds: 0
          periodSeconds: 10
          failureThreshold: 30
          
---
# Vertical Pod Autoscaler
apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: storage-service-vpa
spec:
  targetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: storage-service
  updatePolicy:
    updateMode: "Auto"
  resourcePolicy:
    containerPolicies:
    - containerName: storage-service
      minAllowed:
        cpu: 250m
        memory: 512Mi
      maxAllowed:
        cpu: 4
        memory: 8Gi
                            </code>
                        </div>
                    </div>

                    <!-- Network Performance -->
                    <div class="optimization-technique">
                        <div class="technique-header">
                            <div class="technique-icon">
                                <i class="ti ti-network"></i>
                            </div>
                            <h4 class="technique-title">Network Performance</h4>
                            <div class="technique-impact impact-medium">
                                <i class="ti ti-trending-up"></i>
                                30% Lower Latency
                            </div>
                        </div>
                        
                        <p>Optimize Kubernetes networking:</p>
                        <div class="code-playground">
                            <code class="language-yaml">
# Use hostNetwork for critical services
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: high-performance-proxy
spec:
  template:
    spec:
      hostNetwork: true
      dnsPolicy: ClusterFirstWithHostNet
      
      containers:
      - name: proxy
        image: envoyproxy/envoy:v1.25.0
        
        # Enable CPU affinity
        resources:
          requests:
            cpu: "2"
          limits:
            cpu: "2"
            
        # Pin to specific CPUs
        securityContext:
          capabilities:
            add:
            - NET_ADMIN
            - SYS_NICE
            
---
# Service with session affinity
apiVersion: v1
kind: Service
metadata:
  name: storage-service
spec:
  sessionAffinity: ClientIP
  sessionAffinityConfig:
    clientIP:
      timeoutSeconds: 3600
      
  # IPVS mode for better performance
  ipvs:
    scheduler: "lc"  # Least connection
    
---
# Network Policy for reduced overhead
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-storage-ingress
spec:
  podSelector:
    matchLabels:
      app: storage-service
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          role: api-gateway
    ports:
    - protocol: TCP
      port: 8080
                            </code>
                        </div>
                    </div>

                    <!-- Node Tuning -->
                    <div class="optimization-technique">
                        <div class="technique-header">
                            <div class="technique-icon">
                                <i class="ti ti-server-2"></i>
                            </div>
                            <h4 class="technique-title">Node-Level Tuning</h4>
                            <div class="technique-impact impact-high">
                                <i class="ti ti-trending-up"></i>
                                System-wide Impact
                            </div>
                        </div>
                        
                        <p>Kernel and system-level optimizations:</p>
                        <div class="code-playground">
                            <code class="language-bash">
#!/bin/bash
# Node optimization script

# Network optimizations
cat >> /etc/sysctl.conf << EOF
# Increase TCP buffer sizes
net.core.rmem_max = 134217728
net.core.wmem_max = 134217728
net.ipv4.tcp_rmem = 4096 87380 134217728
net.ipv4.tcp_wmem = 4096 65536 134217728

# Enable TCP Fast Open
net.ipv4.tcp_fastopen = 3

# Increase connection tracking
net.netfilter.nf_conntrack_max = 1000000
net.netfilter.nf_conntrack_tcp_timeout_established = 86400

# Reduce TCP keepalive time
net.ipv4.tcp_keepalive_time = 600
net.ipv4.tcp_keepalive_intvl = 60
net.ipv4.tcp_keepalive_probes = 10

# Enable BBR congestion control
net.core.default_qdisc = fq
net.ipv4.tcp_congestion_control = bbr

# File system optimizations
fs.file-max = 2097152
fs.inotify.max_user_watches = 524288
fs.inotify.max_user_instances = 512

# Virtual memory tuning
vm.swappiness = 10
vm.dirty_ratio = 15
vm.dirty_background_ratio = 5
EOF

# Apply settings
sysctl -p

# CPU governor for performance
for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do
    echo performance > $cpu
done

# Disable transparent huge pages
echo never > /sys/kernel/mm/transparent_hugepage/enabled
echo never > /sys/kernel/mm/transparent_hugepage/defrag

# IRQ affinity for network cards
systemctl start irqbalance
echo 2 > /proc/irq/24/smp_affinity_list  # Example for NIC IRQ

# Container runtime optimization
cat >> /etc/docker/daemon.json << EOF
{
  "storage-driver": "overlay2",
  "storage-opts": [
    "overlay2.override_kernel_check=true"
  ],
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "10m",
    "max-file": "3"
  },
  "default-ulimits": {
    "nofile": {
      "Name": "nofile",
      "Hard": 1048576,
      "Soft": 1048576
    }
  }
}
EOF

systemctl restart docker
                            </code>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Performance Testing Section -->
            <section id="testing-performance" class="docs-section">
                <div class="section-header">
                    <h2 class="section-title">Performance Testing</h2>
                    <div class="section-meta">
                        <span class="section-badge">Best Practices</span>
                    </div>
                </div>

                <div class="section-content">
                    <div class="performance-testing-guide">
                        <h3>Comprehensive Performance Testing Strategy</h3>
                        
                        <!-- Load Testing -->
                        <div class="optimization-technique">
                            <div class="technique-header">
                                <div class="technique-icon">
                                    <i class="ti ti-test-pipe"></i>
                                </div>
                                <h4 class="technique-title">Load Testing Suite</h4>
                            </div>
                            
                            <p>Production-grade load testing with k6:</p>
                            <div class="code-playground">
                                <code class="language-javascript">
// k6 load test script
import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate } from 'k6/metrics';

// Custom metrics
const errorRate = new Rate('errors');
const successRate = new Rate('success');

// Test configuration
export const options = {
  stages: [
    { duration: '5m', target: 100 },   // Ramp up to 100 users
    { duration: '10m', target: 1000 }, // Ramp up to 1000 users
    { duration: '20m', target: 5000 }, // Ramp up to 5000 users
    { duration: '10m', target: 5000 }, // Stay at 5000 users
    { duration: '5m', target: 0 },     // Ramp down to 0 users
  ],
  thresholds: {
    http_req_duration: ['p(99)<500'], // 99% of requests under 500ms
    errors: ['rate<0.1'],             // Error rate under 10%
    success: ['rate>0.9'],            // Success rate over 90%
  },
};

const BASE_URL = 'https://api.neoservicelayer.com';
const API_KEY = __ENV.API_KEY;

export default function () {
  // Test storage service
  const storagePayload = JSON.stringify({
    key: `test-${__VU}-${__ITER}`,
    value: { data: 'test data', timestamp: Date.now() },
    metadata: { source: 'load-test' }
  });
  
  const storageRes = http.post(`${BASE_URL}/storage/store`, storagePayload, {
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${API_KEY}`,
    },
    tags: { name: 'StorageStore' },
  });
  
  // Check response
  const storageSuccess = check(storageRes, {
    'status is 200': (r) => r.status === 200,
    'response time < 500ms': (r) => r.timings.duration < 500,
    'has transaction ID': (r) => JSON.parse(r.body).data.transactionId !== undefined,
  });
  
  errorRate.add(!storageSuccess);
  successRate.add(storageSuccess);
  
  // Test identity service
  const identityRes = http.get(`${BASE_URL}/identity/verify`, {
    headers: {
      'Authorization': `Bearer ${API_KEY}`,
    },
    tags: { name: 'IdentityVerify' },
  });
  
  check(identityRes, {
    'identity status is 200': (r) => r.status === 200,
  });
  
  sleep(1);
}

// Spike test configuration
export const spikeTestOptions = {
  stages: [
    { duration: '10s', target: 100 },
    { duration: '1m', target: 100 },
    { duration: '10s', target: 10000 }, // Spike to 10k users
    { duration: '3m', target: 10000 },
    { duration: '10s', target: 100 },
    { duration: '3m', target: 100 },
    { duration: '10s', target: 0 },
  ],
};

// Stress test to find breaking point
export const stressTestOptions = {
  stages: [
    { duration: '2m', target: 1000 },
    { duration: '5m', target: 5000 },
    { duration: '5m', target: 10000 },
    { duration: '5m', target: 20000 },
    { duration: '5m', target: 30000 },
    { duration: '5m', target: 40000 },
    { duration: '5m', target: 50000 },
  ],
};
                                </code>
                            </div>
                        </div>

                        <!-- Continuous Performance Testing -->
                        <div class="optimization-technique">
                            <div class="technique-header">
                                <div class="technique-icon">
                                    <i class="ti ti-git-merge"></i>
                                </div>
                                <h4 class="technique-title">CI/CD Performance Gates</h4>
                            </div>
                            
                            <p>Automated performance regression detection:</p>
                            <div class="code-playground">
                                <code class="language-yaml">
# GitHub Actions performance test
name: Performance Tests
on:
  pull_request:
    branches: [main]
  schedule:
    - cron: '0 */6 * * *' # Every 6 hours

jobs:
  performance-test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup k6
      run: |
        sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
        echo "deb https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
        sudo apt-get update
        sudo apt-get install k6
    
    - name: Run performance tests
      env:
        API_KEY: ${{ secrets.PERF_TEST_API_KEY }}
      run: |
        k6 run \
          --out influxdb=http://metrics.internal:8086/k6 \
          --tag testrun=${{ github.run_id }} \
          tests/performance/load-test.js
    
    - name: Analyze results
      run: |
        python scripts/analyze-performance.py \
          --baseline main \
          --current ${{ github.sha }} \
          --threshold 10 # 10% regression threshold
    
    - name: Comment PR
      if: failure()
      uses: actions/github-script@v6
      with:
        script: |
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: '⚠️ Performance regression detected! See [test results](https://grafana.internal/d/k6-results)'
          })
                                </code>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Optimization Checklists Section -->
            <section id="checklists" class="docs-section">
                <div class="section-header">
                    <h2 class="section-title">Performance Optimization Checklists</h2>
                    <div class="section-meta">
                        <span class="section-badge">Quick Reference</span>
                    </div>
                </div>

                <div class="section-content">
                    <div class="optimization-checklists">
                        <h3>Pre-Production Performance Checklist</h3>
                        
                        <div class="checklist-category">
                            <h4>✅ Application Layer</h4>
                            <ul class="performance-checklist">
                                <li>Enable response compression (gzip/brotli)</li>
                                <li>Implement request/response caching</li>
                                <li>Use connection pooling for all external services</li>
                                <li>Enable HTTP/2 and keep-alive connections</li>
                                <li>Implement circuit breakers for external calls</li>
                                <li>Use async/non-blocking I/O</li>
                                <li>Profile and optimize hot code paths</li>
                                <li>Minimize JSON serialization overhead</li>
                                <li>Implement request batching where applicable</li>
                                <li>Use pagination for large data sets</li>
                            </ul>
                        </div>
                        
                        <div class="checklist-category">
                            <h4>✅ Database Layer</h4>
                            <ul class="performance-checklist">
                                <li>Create appropriate indexes for all queries</li>
                                <li>Enable query plan caching</li>
                                <li>Configure connection pooling (PgBouncer)</li>
                                <li>Implement read replicas for read-heavy workloads</li>
                                <li>Use prepared statements</li>
                                <li>Enable statement timeout</li>
                                <li>Vacuum and analyze tables regularly</li>
                                <li>Partition large tables</li>
                                <li>Monitor slow query log</li>
                                <li>Use materialized views for complex aggregations</li>
                            </ul>
                        </div>
                        
                        <div class="checklist-category">
                            <h4>✅ Caching Layer</h4>
                            <ul class="performance-checklist">
                                <li>Implement multi-level caching (L1/L2/L3)</li>
                                <li>Configure Redis cluster with persistence</li>
                                <li>Set appropriate TTLs for all cache entries</li>
                                <li>Implement cache warming strategies</li>
                                <li>Monitor cache hit/miss ratios</li>
                                <li>Use cache-aside pattern with stampede protection</li>
                                <li>Implement cache invalidation strategy</li>
                                <li>Enable Redis pipeline for batch operations</li>
                                <li>Configure memory limits and eviction policies</li>
                                <li>Use consistent hashing for cache distribution</li>
                            </ul>
                        </div>
                        
                        <div class="checklist-category">
                            <h4>✅ Infrastructure Layer</h4>
                            <ul class="performance-checklist">
                                <li>Configure HPA with appropriate metrics</li>
                                <li>Set resource requests/limits based on profiling</li>
                                <li>Enable cluster autoscaling</li>
                                <li>Use SSD storage for databases</li>
                                <li>Configure node affinity for critical services</li>
                                <li>Enable kernel tuning on nodes</li>
                                <li>Use IPVS mode for kube-proxy</li>
                                <li>Configure ingress caching</li>
                                <li>Enable gRPC where applicable</li>
                                <li>Monitor and alert on resource usage</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Production Tuning Parameters -->
                    <div class="production-tuning">
                        <h3>Production Tuning Parameters</h3>
                        
                        <div class="tuning-parameter">
                            <div class="parameter-info">
                                <h5 class="parameter-name">GOMAXPROCS</h5>
                                <p class="parameter-description">Number of OS threads for Go runtime</p>
                            </div>
                            <div class="parameter-value">= CPU cores</div>
                        </div>
                        
                        <div class="tuning-parameter">
                            <div class="parameter-info">
                                <h5 class="parameter-name">Database Pool Size</h5>
                                <p class="parameter-description">Optimal connection pool size</p>
                            </div>
                            <div class="parameter-value">= (cores × 2) + spindles</div>
                        </div>
                        
                        <div class="tuning-parameter">
                            <div class="parameter-info">
                                <h5 class="parameter-name">Redis Max Clients</h5>
                                <p class="parameter-description">Maximum concurrent Redis connections</p>
                            </div>
                            <div class="parameter-value">10000</div>
                        </div>
                        
                        <div class="tuning-parameter">
                            <div class="parameter-info">
                                <h5 class="parameter-name">Nginx Worker Processes</h5>
                                <p class="parameter-description">Number of nginx worker processes</p>
                            </div>
                            <div class="parameter-value">auto (= CPU cores)</div>
                        </div>
                        
                        <div class="tuning-parameter">
                            <div class="parameter-info">
                                <h5 class="parameter-name">Kubernetes DNS Cache</h5>
                                <p class="parameter-description">NodeLocal DNSCache for reduced latency</p>
                            </div>
                            <div class="parameter-value">Enabled</div>
                        </div>
                    </div>
                </div>
            </section>

        </main>
    </div>

    <!-- JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script src="../src/scripts/navigation.js"></script>
    <script src="../src/scripts/docs-search.js"></script>
    <script src="../src/scripts/code-playground.js"></script>
    
    <!-- Performance charts -->
    <script>
        // Response time distribution chart
        const ctx = document.getElementById('responseTimeChart').getContext('2d');
        const responseTimeChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: ['0ms', '10ms', '25ms', '50ms', '100ms', '250ms', '500ms', '1s', '2s', '5s'],
                datasets: [{
                    label: 'Response Time Distribution',
                    data: [0, 15, 45, 75, 92, 97, 99, 99.5, 99.9, 100],
                    borderColor: '#3b82f6',
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    tension: 0.4,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Cumulative Response Time Distribution (Percentiles)'
                    },
                    legend: {
                        display: false
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 100,
                        ticks: {
                            callback: function(value) {
                                return value + '%';
                            }
                        }
                    }
                }
            }
        });
    </script>
</body>
</html>